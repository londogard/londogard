<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Londogard Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Londogard Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><title data-react-helmet="true">KotlinJS, ONNX and Deep Learning in the browser | Londogard Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://blog.londogard.com/blog/kotlinjs-onnx-deep-learning-browser"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" name="keywords" content="nlp, kotlin, jvm, deep-learning, machine-learning, blog"><meta data-react-helmet="true" property="og:title" content="KotlinJS, ONNX and Deep Learning in the browser | Londogard Blog"><meta data-react-helmet="true" name="description" content="Ever wanted to deploy State-of-the-Art Deep Learning models in the browser? In this blog you&#x27;ll learn about how to run inference through onnx webruntime directly inside the browser!"><meta data-react-helmet="true" property="og:description" content="Ever wanted to deploy State-of-the-Art Deep Learning models in the browser? In this blog you&#x27;ll learn about how to run inference through onnx webruntime directly inside the browser!"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2022-01-28T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/lundez"><meta data-react-helmet="true" property="article:tag" content="kotlin,web,deep-learning"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://blog.londogard.com/blog/kotlinjs-onnx-deep-learning-browser"><link data-react-helmet="true" rel="alternate" href="https://blog.londogard.com/blog/kotlinjs-onnx-deep-learning-browser" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://blog.londogard.com/blog/kotlinjs-onnx-deep-learning-browser" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.2b27dec1.css">
<link rel="preload" href="/assets/js/runtime~main.1d03df6a.js" as="script">
<link rel="preload" href="/assets/js/main.b98f4283.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.ico" alt="Londogard logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon.ico" alt="Londogard logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Londogard Blog</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/blog/archive">Blog Archive</a><a class="navbar__item navbar__link" href="/presentations">Presentations</a></div><div class="navbar__items navbar__items--right"><a href="https://londogard.com/about" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>About<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://londogard.com/projects" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>Londogard Projects<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/londogard" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/timeseries-pt-3">Forecasting Crypto Prices using Deep Learning (Time Series #3)</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/timeseries-pt-2">Predicting Stock Prices using classical machine Learning (Time Series #2)</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/timeseries-pt-1">Decomposing &amp; Working with Time Series (Time Series #1)</a></li><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/blog/kotlinjs-onnx-deep-learning-browser">KotlinJS, ONNX and Deep Learning in the browser</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/16/nlp-toolkit-release">Release nlp (londogard-nlp-toolkit) 1.1.0</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">KotlinJS, ONNX and Deep Learning in the browser</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-01-28T00:00:00.000Z" itemprop="datePublished">January 28, 2022</time> Â· <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><a href="https://github.com/lundez" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_o0gy" src="https://github.com/lundez.png" alt="Hampus LondÃ¶gÃ¥rd"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/lundez" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hampus LondÃ¶gÃ¥rd</span></a></div><small class="avatar__subtitle" itemprop="description">Main Contributor of Londogard</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>One day I had the crazy idea to try two non-mainstream things out at the same time. On top of that I figured I&#x27;d combine them in the same project, imagine that!</p><p>Preview of final result running model inference in the browser using KotlinJS, ONNX &amp; fritz2:
<img src="https://user-images.githubusercontent.com/7490199/151235880-2546faa6-5798-48b4-84b9-db71c20808d8.gif" alt="model inference in browser gif"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="quick-kotlin-js">Quick Kotlin JS<a class="hash-link" href="#quick-kotlin-js" title="Direct link to heading">â€‹</a></h2><p>KotlinJS resembles TypeScript (TS) in the sense that it&#x27;s typed and transpiles into JavaScript (JS) at the end of the day. The final JS code runs directly in the browser or through Node.js.  </p><p>What makes KotlinJS stand out? In my optinion it picks up where TS leaves. By adding (almost) all of the Kotlin ecosystem we get a really superb toolbox out-of-the-box, which is more than simply types. Some of the awesome perks are coroutines and collections.<br>
<!-- -->As someone who has done a lot of backend development in Scala, with some Java, it feels like home because of the familiar apperance and interaction.<br>
<!-- -->Having sweet syntax, superb typing I feel a great preference toward KotlinJS even if TS is closer to JS making transpiled code easier to reason about.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="quick-onnx">Quick ONNX<a class="hash-link" href="#quick-onnx" title="Direct link to heading">â€‹</a></h2><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><blockquote><p><a href="https://en.wikipedia.org/wiki/Open_Neural_Network_Exchange" target="_blank" rel="noopener noreferrer">Open Neural Network Exchange</a> (ONNX) Runtime is a open format created by Facebook, Microsoft &amp; others, and is part of <em>Linux Foundation AI</em>. </p></blockquote></div></div><p>ONNX is an open polyglot format, meaning that you can run Neural Networks from multiple coding languages. This in turn promotes innovation and collaboration, especially through the fact that you can run your State-of-the-Art model almost everywhere, including C# and Java.<br>
<!-- -->ONNX is a impressive feat that allows companies to reduce their inference time by magnitudes, cherry on top it reduces code complexity when models are deployed directly in the original backend.</p><p>Recently ONNX added a new runtime, <strong>ONNX-webruntime</strong>, which enables ONNX models to run directly inside the browser. Simply take your PyTorch/Tensorflow model, convert to ONNX and then run! Incredible! ðŸŽ‰.<br>
<!-- -->ONNX-webruntime leverages <strong>WebGL</strong> as GPU and <strong>WASM with SIMD</strong> as CPU.<br>
<!-- -->Simple edge deployment is here!</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-set-up">The Set Up<a class="hash-link" href="#the-set-up" title="Direct link to heading">â€‹</a></h2><p>The set up is simple,</p><ul><li>Kotlin JS project</li><li><code>fritz2</code> as web framework</li><li><code>onnx-webruntime</code> as deep learning inference tool</li></ul><p>For this demo I could&#x27;ve used raw html elements in the Kotlin JS code, but it&#x27;s more fun to use something enjoyable, as such I chose <code>fritz2</code> that I introduce below ðŸ‘‡.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="introducing-fritz2">Introducing fritz2<a class="hash-link" href="#introducing-fritz2" title="Direct link to heading">â€‹</a></h3><p>Introducing <a href="https://www.fritz2.dev/" target="_blank" rel="noopener noreferrer"><strong>fritz2</strong></a>, a small but impressive framework.<br>
<!-- -->Because of the size you can understand the full idea and implementation, which is something you cannot say about React. Through simple DSLs, superb usage of <code>Flow&lt;T&gt;</code> you end up with a simple yet powerful model that maps perfectly to my own mind.<br>
<!-- -->In my opinion <strong>fritz2 feels less magic</strong> while very powerful and simple. Everything works with full typing and no hacks. Cherry on the top? No virtual dom!</p><p>Fritz2 has a extra <a href="https://components.fritz2.dev/" target="_blank" rel="noopener noreferrer">components library</a> which you can additionally install. This library contains simple components to make your development much faster, with things like File input, Data Tables and much more!</p><p>Personally I even did my own wedding website using <code>fritz2</code>, and it ended up pretty great!
<img alt="fritz2 gui" src="/assets/images/wedding_fritz2-f9d5c8604e9bc209c363765541d424f7.png" width="955" height="884"></p><blockquote><p>My personal wedding site created in fritz2</p></blockquote><h3 class="anchor anchorWithStickyNavbar_mojV" id="onnx-typing-in-kotlinjs">ONNX typing in KotlinJS<a class="hash-link" href="#onnx-typing-in-kotlinjs" title="Direct link to heading">â€‹</a></h3><p>Using <code>dukat</code> (included by default in Kotlin &gt; 1.6 or perhaps earlier) it&#x27;s possible to generate external types/bindings for any TypeScript project.<br>
<!-- -->Guess what, ONNXRuntime Web is full TypeScript - awesome!</p><p>Unfortunately ONNX has some really weird structure which I&#x27;d call non-standard, this ends up not working great in <code>dukat</code>-generation...<br>
<!-- -->Luckily enough it is <strong>easy to make your own bindings</strong>. Keep your breath for now, I&#x27;ll share them later in this post, but for now let&#x27;s say that it&#x27;s like a .d.ts-file.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-implementation">The Implementation<a class="hash-link" href="#the-implementation" title="Direct link to heading">â€‹</a></h2><p>We need to create our project, I usually do it by scratch but if you want to keep it easy setting up the MPP project for <code>friz2</code> you can make sure to use their <a href="https://github.com/jwstegemann/fritz2-template" target="_blank" rel="noopener noreferrer">template project</a>. Make sure to include the fritz2 component library, as it&#x27;ll be used in the implementation.<br>
<!-- -->Please note that the focus will be ONNX, as such I&#x27;ll save some <code>fritz2</code> details for another post.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="basic-ui">Basic UI<a class="hash-link" href="#basic-ui" title="Direct link to heading">â€‹</a></h3><p><strong>Getting the skeleton UI up</strong><br>
<!-- -->In the &quot;main&quot; file of the js-folder, but not as in js-code ðŸ˜‰, you&#x27;ll need to set up a file and image element.</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val imgSrc = RootStore(&quot;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    render {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val srcImg = img(id = &quot;img-from&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            src(imgSrc.data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accept(&quot;image/*&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        button { text(&quot;Single select&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .map { file -&gt; &quot;data:${file.type};base64,${file.content}&quot; } handledBy imgSrc.update</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Breaking down what&#x27;s done</p><ol><li>A <code>RootStore</code> is a abstraction on top of a <code>(Mutable)StateFlow</code>  which is a <code>Flow</code> with a state.  <ol><li>In simple terms a <code>Flow</code>  is a <strong>collection of asynchronously computed values</strong> just like you have <code>Sequence</code> and <code>List</code> being collections of synchronously computed values.</li></ol></li><li>A <code>Store</code> is a reactive component that contains our apps state, it can do bidirectional communication with the DOM/GUI.<ol><li>We update <code>imgSrc</code> through the <code>file</code>-component, whenever <code>file</code> is updated.  </li><li><code>&lt;img&gt;</code> listens on changes from <code>imgSrc</code>, hence it&#x27;s updated as <code>imgSrc</code> is updated</li><li>All in all we get <strong>typed</strong> and <strong>no-magic</strong> dynamical updates in our GUI. This is something I love, compared to <code>react</code> and <code>svelte</code> where it seems more magical.</li></ol></li></ol><p>The connector between <code>file</code> and <code>imgSrc</code> is dirty, I hoped to be able to load the <code>b64</code> content directly into a <code>UInt8ClampedArray</code> to have optimal performance, but because the <code>b64</code>-string actually contains PNG/JPEG headers and other things the perfomance gains versus simplicity is not worth it. Hence I transform it from the <code>b64</code>-string (<code>data:image/pdf;base64,&lt;content&gt;</code>) to image and then extract <code>ImageData</code> - annoying but clean.<br>
<!-- -->The detail that <code>&lt;content&gt;</code> in <code>b64</code>-string is only the pixel data haunted me for a long time... I couldn&#x27;t figure why my arrays had the wrong dimensions! ðŸ˜…</p><p>The next step: transfer image from this component to another, while allowing a transformation (neural network inference) in-between.</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">fun loadImgToCanvas(img: Image, canvas: Canvas, context: CanvasRenderingContext2D) {</span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">    if (img.domNode.src.isNotEmpty()) {</span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">        canvas.width = img.domNode.naturalWidth</span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">        canvas.height = img.domNode.naturalHeight</span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">        context.drawImage(img, 0.0, 0.0)</span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val imgSrc = RootStore(&quot;&quot;)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    render {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val srcImg = img(id = &quot;img-from&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            src(imgSrc.data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val targetCanvas = canvas(id = &quot;img-to&quot;) { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val imgContext = targetCanvas.domNode.getContext(&quot;2d&quot;) as CanvasRenderingContext2D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        file { /** same as before ... */ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">        srcImg.domNode.onload { loadImgToCanvas(srcImg, targetCanvas, imgContext) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Whenever <code>srcImg.onload</code> event happens we call <code>loadImgToCanvas</code> which loads <code>img</code> on our canvas.<br>
<strong>Why did I choose to not have a new <code>&lt;img&gt;</code>?</strong> Because we later need to use <code>ImageData</code> and this is the way to have the minimum number of data transitions, trust me ðŸ˜‰.</p><p>Let&#x27;s start adding bindings for ONNX!</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="binding-onnx-and-webruntime">Binding ONNX and webruntime<a class="hash-link" href="#binding-onnx-and-webruntime" title="Direct link to heading">â€‹</a></h3><p>Binding TS/JS is as simple as a <code>.d.ts</code>-file in TS. You define the component to bind, declare the types, e.g. function name, input and outout. Simple as that!</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@file:JsModule(&quot;onnxruntime-web&quot;)   // npm-package</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@file:JsNonModule</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import kotlin.js.Promise  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external abstract class InferenceSession {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun run(feeds: FeedsType): Promise&lt;ReturnType&gt; // FeedsType / ReturnType separately defined the same way as InferenceSession &amp; run.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Moving further we&#x27;ll add a method to extract <code>ImageData</code>&#x27;s <code>UInt8ClampedArray</code> from a <code>img</code>-element using a <code>canvas</code>-element with its <code>CanvasRenderingContext2D</code> (lots of JS/web words, the most I&#x27;ll have in a sentence, peeew! ðŸ˜…)</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun imgToUInt8ClampedArray(img: HTMLImageElement, ctx: CanvasRenderingContext2D): Uint8ClampedArray {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val canvas = ctx.canvas</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    canvas.width = img.naturalWidth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    canvas.height = img.naturalHeight</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.drawImage(img, 0.0, 0.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ctx.getImageData(0.0, 0.0, img.naturalWidth.toDouble(), img.naturalHeight.toDouble()).data // extract data from ImageData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The <code>UInt8ClampedArray</code> has to be transformed into a <code>Float32Array</code> that the model expects.<br>
<!-- -->Sounds easy? Think again!<br>
<!-- -->Because JS is not a data science language it&#x27;s not surprising that the data is &quot;incorrectly&quot; ordered. The model expects the data to be formed as <code>[3,width,height]</code> where 3 is the number of dimensions, in our case RGB, but in JS it&#x27;s the reverse way. On top of the wrong ordering JS has a fourth dimension, namely transparency. Following all that knowledge we can transform the array.</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun uInt8ClampedToFloat32Array(data: Uint8ClampedArray): Float32Array {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val floats = Float32Array(data.length / 4 * 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val rgb =listOf(0, data.length / 4, data.length / 4 * 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 0untildata.lengthstep4) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        floats[rgb[0] + i / 4] = data[i + 0] / 255f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        floats[rgb[1] + i / 4] = data[i + 1] / 255f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        floats[rgb[2] + i / 4] = data[i + 2] / 255f // Skip i+3 as that&#x27;s ALPHA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return floats</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As ONNX expects <code>Tensor</code> we need to transform the <code>Float32Array</code> into a <code>Tensor</code> and then into <code>FeedsInput</code> which is a <code>Object</code> of the data, luckily that&#x27;s very easy after our binding is done.</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun tensorToInput(tensor: Tensor, inputName: String = &quot;input&quot;): FeedsType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val input: dynamic = object {} // To hack JS Objects</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input[inputName] = tensor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return input.unsafeCast&lt;FeedsType&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val tensor = Tensor(&quot;float32&quot;, floats, arrayOf(1, 3, srcImg.domNode.naturalWidth, srcImg.domNode.naturalHeight))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val input = tensorToInput(tensor)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>...and it&#x27;s time to run the model! ðŸ¥³</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val ir = InferenceSession.create(&quot;./dce2.onnx&quot;).await()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val out = ir.run(input).await()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val outTensor = out[&quot;output&quot;] as Tensor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val outData = outTensor.data as Float32Array</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The output then needs to have the reverse transform applied to be viewable in the browser. That is, reverse axis, add fourth dimension and cast into <code>int</code>.  </p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// Calling on the output data, before converting to UInt8Clamped..</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (i in 0untiloutData.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outData[i] = min(outData[i], 1f) * 255f // `min` to not go above 255</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun float32ToUInt8Clamped(data: Float32Array): Uint8ClampedArray {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val rgb =arrayOf(0, data.length / 3, data.length / 3 * 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val intOut = Uint8ClampedArray(data.length / 3 * 4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 0untilintOut.length / 4) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intOut.asDynamic()[i * 4 + 0] = data[rgb[0] + i].toInt()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intOut.asDynamic()[i * 4 + 1] = data[rgb[1] + i].toInt()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intOut.asDynamic()[i * 4 + 2] = data[rgb[2] + i].toInt()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intOut.asDynamic()[i * 4 + 3] = 255 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return intOut</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>As you might notice we cast a lot <code>asDynamic()</code>, this is because of a current bug in Kotlin JS where it sends signed <code>Byte</code> when it should be an unsigned <code>Byte</code>.<br>
<!-- -->See the current issue at <a href="https://youtrack.jetbrains.com/issue/KT-24583" target="_blank" rel="noopener noreferrer">youtrack.jetbrains.com</a>.</p><p>We <strong>finally got all the pieces</strong>, how about gluing it all together? ðŸ˜„</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="solving-the-puzzle">Solving the puzzle<a class="hash-link" href="#solving-the-puzzle" title="Direct link to heading">â€‹</a></h3><p>The model I wish to use has a dynamic input/output size, e.g. the image dimensions, I need to recreate the session or else it will throw as ONNX expects the last used shape on new runs. This is not true as images are of different sizes.<br>
<!-- -->One solution would be to preprocess the image to always be the same size, but I prefer to return the image in the original dimensions for this use-case.</p><details class="details_lb9f alert alert--info details_BAp3" data-collapsed="true"><summary>View code!</summary><div><div class="collapsibleContent_i85q"><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun imgToUInt8ClampedArray(img: HTMLImageElement, ctx: CanvasRenderingContext2D): Uint8ClampedArray {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** same code as previously */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun float32ToUInt8Clamped(data: Float32Array): Uint8ClampedArray {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** same code as previously */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun tensorToInput(tensor: Tensor, inputName: String = &quot;input&quot;): FeedsType {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** same code as previously */  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun uInt8ClampedToFloat32Array(data: Uint8ClampedArray): Float32Array {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** same code as previously */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@OptIn(ExperimentalTime::class, ExperimentalCoroutinesApi::class)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun main() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val flow = RootStore(&quot;&quot;)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val isLoaded = RootStore(&quot;&quot;)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val webgl: dynamic = object {}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    webgl[&quot;executionProviders&quot;] = arrayOf(&quot;webgl&quot;)  // want that WebGL GPU power</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    render {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         val srcImg = img(id = &quot;img-from&quot;) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            src(flow.data)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            domNode.onload = { isLoaded.update(domNode.src) }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val targetCanvas = canvas(id = &quot;img-to&quot;) {}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val imgContext = targetCanvas.domNode.getContext(&quot;2d&quot;) as CanvasRenderingContext2D  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isLoaded.data  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .distinctUntilChanged()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .filter { b64 -&gt; b64.isNotEmpty() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val ir = runCatching { InferenceSession.create(&quot;./dce2.onnx&quot;, webgl).await() }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .onFailure { showAlertToast { alert { title(&quot;Could not load WebGL, using WASM.&quot;) } } }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .getOrDefault(InferenceSession.create(&quot;./dce2.onnx&quot;).await())  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val intData = imgToUInt8ClampedArray(srcImg.domNode, imgContext)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val floats = uInt8ClampedToFloat32Array(intData)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val tensor = Tensor(&quot;float32&quot;, floats, arrayOf(1, 3, srcImg.domNode.naturalWidth, srcImg.domNode.naturalHeight))  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val input = tensorToInput(tensor)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val out = ir.run(input).await()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val outTensor = out[&quot;output&quot;] as Tensor  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val outData = outTensor.data as Float32Array  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (i in 0 until outData.length) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                outData[i] = min(outData[i], 1f) * 255f  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val intOut = float32ToUInt8Clamped(outData)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ImageData(intOut, srcImg.domNode.naturalWidth, srcImg.domNode.naturalHeight)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } handledBy { imageData -&gt; imgContext.putImageData(imageData, 0.0, 0.0) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accept(&quot;image/*&quot;)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        button { text(&quot;Single select&quot;) }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }.map { file -&gt; &quot;data:${file.type};base64,${file.content}&quot; } handledBy flow.update  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div></div></details><p>With the joining bindings for ONNX.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="thoughts">Thoughts<a class="hash-link" href="#thoughts" title="Direct link to heading">â€‹</a></h2><p>Wrapping it all together I feel like I want to leave with the sentiment that KotlinJS is a player, ONNX Webruntime certainly is capable and I&#x27;ll continue creating small MVP:s and demos using this setup! </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="kotlinjs-vs-typescript">KotlinJS vs TypeScript<a class="hash-link" href="#kotlinjs-vs-typescript" title="Direct link to heading">â€‹</a></h3><p>Regarding KotlinJS I believe it&#x27;s still behind TypeScript in terms of compatibility. I need to do more plumbing than someone using TS would, especially as <code>dukat</code> don&#x27;t solve all my problems magically. Luckily it&#x27;s very easy to make those bindings!</p><p>In terms of how usable it is I find it much better than TypeScript, the experience when working with KotlinJS-code (e.g. interfacing std-lib, pure kotlin code or bindings) is so much better than TypeScript - it&#x27;s just like when I write my good ol&#x27; JVM applications. I&#x27;m not sure if I&#x27;m missing something, but TypeScript&#x27;s typesystem always felt a bit choppy, just like Pythons. Sometimes I don&#x27;t get the intellisense I&#x27;m expecting.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="onnx-in-the-web">ONNX in the web<a class="hash-link" href="#onnx-in-the-web" title="Direct link to heading">â€‹</a></h3><p>The performance when using WebGL is definitely better than I expected, but not as good as using the usual runtime. Something I did notice during my testing is that <strong>it scales badly with size</strong>, using a high-res image (3000x4000) ends up slowing my whole computer. I know I&#x27;m not really working on a separate thread or anything, but it&#x27;s too bad it doesn&#x27;t scale well. Further there&#x27;s an internal max-limit somewhere around the same dimensions, which I hit once with another image.</p><blockquote><p>Personally, including these issues, I&#x27;m left impressed <strong>about how easy it is to set up a completely custom model</strong> to run inside the browser (&quot;on the edge&quot;), where we <strong>don&#x27;t have to care about architecture, OS or anything</strong> and that it works efficiently enough to use. </p></blockquote><p>I can see this as a key tool to start-ups and larger companies to reduce costs &amp; inference-time (as computation happens on the edge). On top of the $&#x27;s I see a win for privacy as the data will never leave the users device, which in turn simplifies GDPR compliance and much more!</p><p>Even moving inference to the edge through a common simple interface that is the browser we&#x27;ll still have plenty of need for servers, not only serving larger models for complex problems, old devices and batch inference of larger amounts of data.</p><p>The future is indeed still moving fast for Deep Learning and I can&#x27;t wait to see where we&#x27;re moving!<br>
<strong>My own prediction:</strong> Deep Learning will simply ignore <em>serverless</em> computing and jump straight to <em>edge computing</em> in an effort to reduce costs.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="the-combination">The Combination<a class="hash-link" href="#the-combination" title="Direct link to heading">â€‹</a></h3><p>Combining ONNX &amp; KotlinJS (perhaps testing Compose rather than fritz2) is something I&#x27;m gonna keep on doing in the future to deploy demos. Either deploying through Github Pages or my own Raspberry Pi this will be piece a cake as my devices don&#x27;t have to do the inference, keeping my costs down for fun demos.</p><p><strong>Demo:</strong> A live demo can be found <a href="https://photo-fritz2.pages.dev/" target="_blank" rel="noopener noreferrer">here</a>.</p><p>And the code can be found on <a href="https://github.com/londogard/photo-fritz2" target="_blank" rel="noopener noreferrer">github.com/londogard/photo-fritz2</a>, but be careful - it&#x27;s not that beautiful right now ðŸ˜°</p><p>That&#x27;s it for now.. ðŸ¥³<br>
<!-- -->~Hampus LondÃ¶gÃ¥rd</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/kotlin">kotlin</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/web">web</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/deep-learning">deep-learning</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/londogard/londogard/blog/2022-01-28-kotlinjs-onnx-deep-learning-in-browser/index.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/timeseries-pt-1"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Decomposing &amp; Working with Time Series (Time Series #1)</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/01/16/nlp-toolkit-release"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Release nlp (londogard-nlp-toolkit) 1.1.0</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#quick-kotlin-js" class="table-of-contents__link toc-highlight">Quick Kotlin JS</a></li><li><a href="#quick-onnx" class="table-of-contents__link toc-highlight">Quick ONNX</a></li><li><a href="#the-set-up" class="table-of-contents__link toc-highlight">The Set Up</a><ul><li><a href="#introducing-fritz2" class="table-of-contents__link toc-highlight">Introducing fritz2</a></li><li><a href="#onnx-typing-in-kotlinjs" class="table-of-contents__link toc-highlight">ONNX typing in KotlinJS</a></li></ul></li><li><a href="#the-implementation" class="table-of-contents__link toc-highlight">The Implementation</a><ul><li><a href="#basic-ui" class="table-of-contents__link toc-highlight">Basic UI</a></li><li><a href="#binding-onnx-and-webruntime" class="table-of-contents__link toc-highlight">Binding ONNX and webruntime</a></li><li><a href="#solving-the-puzzle" class="table-of-contents__link toc-highlight">Solving the puzzle</a></li></ul></li><li><a href="#thoughts" class="table-of-contents__link toc-highlight">Thoughts</a><ul><li><a href="#kotlinjs-vs-typescript" class="table-of-contents__link toc-highlight">KotlinJS vs TypeScript</a></li><li><a href="#onnx-in-the-web" class="table-of-contents__link toc-highlight">ONNX in the web</a></li><li><a href="#the-combination" class="table-of-contents__link toc-highlight">The Combination</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Support Londogard</div><ul class="footer__items"><li class="footer__item"><a href="https://www.buymeacoffee.com/hlondogard" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 60px !important;width: 217px !important;"></a></li><li class="footer__item"><div style="display: flex; align-items: center;"><iframe src="https://github.com/sponsors/Lundez/button" title="Sponsor Lundez" height="35" width="116" style="border: 0;"></iframe><div>&nbsp;on GitHub</div></div></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/londogard" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Feeds</div><ul class="footer__items"><li class="footer__item"><a href="https://blog.londogard.com/blog/rss.xml" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>RSS<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://blog.johnnyreilly.com/blog/atom.xml" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Atom<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 Londogard. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1d03df6a.js"></script>
<script src="/assets/js/main.b98f4283.js"></script>
</body>
</html>