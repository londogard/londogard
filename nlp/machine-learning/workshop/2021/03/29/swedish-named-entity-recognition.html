<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface) | Londogard</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface)" />
<meta name="author" content="Hampus Londögård" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance &amp; a much more efficient model." />
<meta property="og:description" content="Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance &amp; a much more efficient model." />
<link rel="canonical" href="https://blog.londogard.com/nlp/machine-learning/workshop/2021/03/29/swedish-named-entity-recognition.html" />
<meta property="og:url" content="https://blog.londogard.com/nlp/machine-learning/workshop/2021/03/29/swedish-named-entity-recognition.html" />
<meta property="og:site_name" content="Londogard" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-03-29T00:00:00-05:00" />
<script type="application/ld+json">
{"url":"https://blog.londogard.com/nlp/machine-learning/workshop/2021/03/29/swedish-named-entity-recognition.html","@type":"BlogPosting","headline":"Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface)","dateModified":"2021-03-29T00:00:00-05:00","datePublished":"2021-03-29T00:00:00-05:00","author":{"@type":"Person","name":"Hampus Londögård"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.londogard.com/nlp/machine-learning/workshop/2021/03/29/swedish-named-entity-recognition.html"},"description":"Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance &amp; a much more efficient model.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.londogard.com/feed.xml" title="Londogard" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header" role="banner">

    <div class="wrapper">
<a class="site-title" rel="author" href="/">Londogard</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>
  
          <div class="trigger">
<a class="page-link" href="/education/">Education: Presentations &amp; Workshops</a><a class="page-link" href="/londogard">Londogard↗</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a>
</div>
        </nav>
</div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface)</h1>
<p class="page-description">Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance &amp; a much more efficient model.</p>
<p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-03-29T00:00:00-05:00" itemprop="datePublished">
        Mar 29, 2021
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Hampus Londögård</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      11 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i> 
      
        <a class="category-tags-link" href="/categories/#nlp">nlp</a>
         
      
        <a class="category-tags-link" href="/categories/#machine-learning">machine-learning</a>
         
      
        <a class="category-tags-link" href="/categories/#workshop">workshop</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1">
<a href="#building-a-swedish-named-entity-recognition-ner-model">Building a Swedish Named Entity Recognition (NER) model</a>
<ul>
<li class="toc-entry toc-h2"><a href="#named-entity-recognition-and-how-it-can-do-your-bidding">Named Entity Recognition and how it can do your bidding</a></li>
<li class="toc-entry toc-h2"><a href="#flairing-the-way-to-success">Flair(ing) the way to success</a></li>
<li class="toc-entry toc-h2"><a href="#swedish-data">Swedish data</a></li>
<li class="toc-entry toc-h2">
<a href="#training-the-flair">Training the flair</a>
<ul>
<li class="toc-entry toc-h3"><a href="#setting-up-the-corpus--dataset">Setting up the Corpus / Dataset</a></li>
<li class="toc-entry toc-h3"><a href="#model-setup">Model Setup</a></li>
<li class="toc-entry toc-h3"><a href="#training-the-model">Training the model</a></li>
<li class="toc-entry toc-h3"><a href="#loading-model-from-checkpoint">Loading model from checkpoint</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#result">Result</a></li>
<li class="toc-entry toc-h2"><a href="#deploying-on-streamlitiosharing">Deploying on streamlit.io/sharing</a></li>
<li class="toc-entry toc-h2"><a href="#outro">Outro</a></li>
</ul>
</li>
</ul>
<p>Not interested in reading the whole article and just wanna play around with the model(s)? Head over to <a href="https://londogard.com/ner">londogard.com/ner</a>.
<img src="https://user-images.githubusercontent.com/7490199/113611097-543f9280-964e-11eb-9e59-bd030c32ad0c.png" alt="image">
<strong>P.S.</strong> The Flair model is available for simple installation through <a href="https://huggingface.co/londogard/flair-swe-ner">huggingface.co’s model hub</a></p>

<h1 id="building-a-swedish-named-entity-recognition-ner-model">
<a class="anchor" href="#building-a-swedish-named-entity-recognition-ner-model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building a Swedish Named Entity Recognition (NER) model</h1>
<p>At <em>Londogard</em> we aim to employ Natural Language Processing (NLP) in a practical manner. The goal is not to create the models of OpenAI or Google, but rather something that is usable from the get-go and performant leading to a simple to use product.<br>
In this post I’ll cover how we at Londogard developed a State-of-the-Art (SotA) Named Entity Recognition (NER) model for Swedish using Flair &amp; huggingface. <img class="emoji" title=":tada:" alt=":tada:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png" height="20" width="20"></p>

<p>It all started last weekend when I was allowed into the <a href="https://streamlit.io/">streamlit.io</a>’s <em>sharing</em> beta. <br>
If you don’t know what streamlit, here’s an excerpt from their frontpage:</p>
<blockquote>
  <p><strong>The fastest way to build and share data apps</strong>
Streamlit turns data scripts into shareable web apps in minutes.<br>
All in Python. All for free. No front‑end experience required.</p>
</blockquote>

<p>Essentially streamlit is a way to combine backend &amp; frontend into a unified script-like experience where the default UI looks pretty good. On top of this script-like experience streamlit has built a powerful yet simple to use cache system.</p>

<blockquote>
  <p>In my opinion creating demos has never been simpler than with streamlit.io</p>
</blockquote>

<p>Back to the problem at hands, I wished to deploy a model through streamlit that actually was a meaningful experience where efficiency and performance are combined, according to the Londogard motto.  <br>
As such I embarked on the journey that was to deploy a NER model for <em>Swedish</em> where Swedish actually isn’t all to common in NLP. Lately <em>Kungliga Biblioteket</em> has been trying to improve this through their <a href="https://github.com/Kungbib/swedish-spacy">spaCy-contribution</a>, which yet has to be included in spaCy, and their <a href="https://huggingface.co/KB/">HuggingFace-contributions</a> where we can find BERT, Electra &amp; Albert pre-trained.<br>
My first idea was to take one of these and fine-tune to finally deploy, but the size of BERT is too large as is.</p>

<p>What choices are left to allow deploy of these models?</p>
<ul>
  <li>Distilling ⚗️</li>
  <li>Quantizing</li>
  <li>Fine-tuning ALBERT on NER
    <ul>
      <li>Performance has been shown to be quite a bit below BERT (7% units) in a paper by KTH, for Swedish.</li>
    </ul>
  </li>
</ul>

<p><em>So what did I do?</em> I did as any other professional and google’d. <br>
A library I hadn’t heard the name of in a year popped up at the top of the results, I was intrigued.<br>
Flair, a library that was created by Zalando Research, now under the flag <code class="language-plaintext highlighter-rouge">/flairnlp</code> which in practice means that the core contributor-group has been changed to Humbold-University of Berlin.<br>
Flair contains the so-called <em>Flair Embeddings</em> which are contextual embeddings of high quality. Flair retains SotA for NER in multiple languages through these and the performance is pretty damn good over all.</p>

<p>Before I dive into the details on how I trained my own model you can find a demo on <a href="https://londogard.com/ner">londogard.com/ner</a>, where the model is deployed through <a href="https://streamlit.io/">streamlit.io</a>.</p>

<h2 id="named-entity-recognition-and-how-it-can-do-your-bidding">
<a class="anchor" href="#named-entity-recognition-and-how-it-can-do-your-bidding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Named Entity Recognition and how it can do your bidding</h2>
<p>As the name suggests NER is the task to recognize entities in text. Entities can be a lot of different things such as the obvious <em>Person</em> but also <em>Location</em>, <em>Organisation</em> &amp; <em>Time</em>. More entities exists and they can really become whatever your data allows (<em>Brand</em>, <em>Medicine</em> or <em>Dosage</em>? You got it!)</p>

<p><strong>Practical use-cases of NER</strong></p>
<ol>
  <li>Automatic anonymization of data</li>
  <li>Medical prescription</li>
  <li>Automatically tag data
    <ul>
      <li>e.g. News tagged by Organisations, Persons &amp; Locations included</li>
    </ul>
  </li>
</ol>

<p>… &amp; much more</p>

<p>In my case I’m simply aiming for the traditional NER model which categorize things like <em>Location</em>, <em>Person</em> &amp; <em>Organisation</em>.</p>

<h2 id="flairing-the-way-to-success">
<a class="anchor" href="#flairing-the-way-to-success" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flair(ing) the way to success</h2>
<p>Flair is a SotA NLP library developed by <a href="https://www.informatik.hu-berlin.de/en/forschung-en/gebiete/ml-en/">Humboldt University of Berlin</a> and friends. As mentioned its core contributors are from Humboldt University of Berlin and the whole idea is to provide contextual embeddings. Some of the things provided through Flair:</p>

<ol>
  <li>Flair Embeddings</li>
  <li>(Easily) Stacked Embeddings
    <ul>
      <li>e.g. combine Transformer, Flair &amp; GloVe for your end-model</li>
    </ul>
  </li>
  <li>Easy access to multiple embeddings
    <ul>
      <li>GloVe, Transformer, ELMo &amp; many more</li>
    </ul>
  </li>
  <li>Simple training of high-performant NER (Token Classifier) Model and a Text Classifier model</li>
</ol>

<p>As mentioned Flair retain SotA in multiple languages for NER, but they do the same for POS.</p>

<p><strong>The Language Model</strong><br>
If you’re curious the simplest Flair embeddings are essentially a Language Model built on Dropout, LSTM &amp; a Linear Layer. Pretty simple.</p>

<p><strong>The Token Classifier (NER/POS)</strong><br>
It’s based on a small LSTM-network with a CRF on top. The LSTM exists to create features for the CRF to learn and tag from. This is a very common approach which yields high accuracy. If you’re aware of what features you wish to use a pure CRF can be very strong, Stanford NLP library was actually for very long based on a CRF and had SotA, but the manual feature engineering can be expensive &amp; hard.</p>

<p><strong>The Text Classifier</strong>
Simply a linear layer on top of the embeddings.</p>

<p><strong>More Models</strong><br>
Flair actually supports two other tasks, <em>Text Regression</em> &amp; <em>Similarity</em> but I won’t go in to those.</p>

<p>More about how I trained my NER will come a bit further down.
To read more about Flair and how they work please check out their <a href="https://github.com/flairNLP/flair">GitHub</a> which also links to the papers.</p>

<h2 id="swedish-data">
<a class="anchor" href="#swedish-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Swedish data</h2>
<p>First of all I had to go find some data and I found crème de la crème in <a href="https://spraakbanken.gu.se/en/resources/suc3">SUC 3.0</a>, because we really do sentence by sentence training in NER it’s not the end of the world that the ‘free’ variant that doesn’t require a research licence is scrambled. Unscrambled data would lead to a better model but it’s still doable.</p>

<p>But as Jeremy Howard proposes, start with small and simple data then expand into your full task. SUC 3.0 is pretty large and slow to train. With some fast googling I found a saviour, <em>klintan</em>. Klintan has created a open Swedish NER dataset based on Webbnyheter 2020 from Språkbanken, it’s semi-manually annotated. This means that he first based it on <em>Gazetters</em>, essentially dataset(s) of entities, and then manually reviewed the data with two different native Swedish Speakers. More people have later added some improvements on top of that, find the full dataset <a href="https://github.com/klintan/swedish-ner-corpus">here</a>, but please note that <em>it’s much smaller</em> than SUC 3.0. <br>
After finding this dataset I read more into Flair and I found out that they actually provide this dataset through their API and in this dataset we have 4 categories PER, ORG, LOC and MISC.</p>

<p>With these two datasets in mind I went ahead to train.</p>

<h2 id="training-the-flair">
<a class="anchor" href="#training-the-flair" aria-hidden="true"><span class="octicon octicon-link"></span></a>Training the flair</h2>
<p>First let me say the <a href="https://github.com/flairNLP/flair/tree/master/resources/docs">documentation</a> is actually pretty good!
First part is to set up the <code class="language-plaintext highlighter-rouge">Corpus</code>.</p>

<h3 id="setting-up-the-corpus--dataset">
<a class="anchor" href="#setting-up-the-corpus--dataset" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting up the Corpus / Dataset</h3>
<p><strong>The built-in <em>klintan/ner-swedish-corpus</em></strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. get the corpus
</span><span class="n">corpus</span><span class="p">:</span> <span class="n">Corpus</span> <span class="o">=</span> <span class="n">NER_SWEDISH</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>

<span class="c1"># 2. what tag do we want to predict?
</span><span class="n">tag_type</span> <span class="o">=</span> <span class="s">'ner'</span>

<span class="c1"># 3. make the tag dictionary from the corpus
</span><span class="n">tag_dictionary</span> <span class="o">=</span> <span class="n">corpus</span><span class="p">.</span><span class="n">make_tag_dictionary</span><span class="p">(</span><span class="n">tag_type</span><span class="o">=</span><span class="n">tag_type</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">tag_dictionary</span><span class="p">)</span>
</code></pre></div></div>
<p><strong>Custom dataset (SUC 3.0, in my case scrambled)</strong><br>
Remember to convert the SUC tags into a IOB format before training. Emil Stenström has kindly created a simple Python-script for this available through <a href="https://github.com/EmilStenstrom/suc_to_iob">github.com/EmilStenstrom/suc_to_iob</a>. First transform the data and later you can run the following code</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">'text'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">'ner'</span><span class="p">}</span>

<span class="c1"># this is the folder in which train, test and dev files reside
</span><span class="n">data_folder</span> <span class="o">=</span> <span class="s">'path/to/data/suc'</span>

<span class="c1"># init a corpus using column format, data folder and the names of the train, dev and test files
</span><span class="n">corpus</span><span class="p">:</span> <span class="n">Corpus</span> <span class="o">=</span> <span class="n">ColumnCorpus</span><span class="p">(</span><span class="n">data_folder</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">train_file</span><span class="o">=</span><span class="s">'train.txt'</span><span class="p">,</span> <span class="n">test_file</span><span class="o">=</span><span class="s">'test.txt'</span><span class="p">,</span> <span class="n">dev_file</span><span class="o">=</span><span class="s">'dev.txt'</span><span class="p">)</span>

<span class="c1"># 2. what tag do we want to predict?
</span><span class="n">tag_type</span> <span class="o">=</span> <span class="s">'ner'</span>

<span class="c1"># 3. make the tag dictionary from the corpus
</span><span class="n">tag_dictionary</span> <span class="o">=</span> <span class="n">corpus</span><span class="p">.</span><span class="n">make_tag_dictionary</span><span class="p">(</span><span class="n">tag_type</span><span class="o">=</span><span class="n">tag_type</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">tag_dictionary</span><span class="p">)</span>
</code></pre></div></div>
<p>With this in mind we’re ready to set up our model for training.</p>

<h3 id="model-setup">
<a class="anchor" href="#model-setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model Setup</h3>
<p>Our model will build on <code class="language-plaintext highlighter-rouge">FlairEmbeddings</code> (e.g. contextual embeddings) and <code class="language-plaintext highlighter-rouge">BytePairEmbeddings</code> which are a bit like classic <code class="language-plaintext highlighter-rouge">WordEmbeddings</code> but done on BPE-tokenized text. This is a really interesting approach which achieves similar performance as <code class="language-plaintext highlighter-rouge">fastText</code> using ~ 0.2 % of the total size (11mb vs 6gb). <br>
The model itself will use a LSTM with a hidden size of 256 and a CRF classifier on top.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 4. initialize embeddings
</span><span class="n">embedding_types</span> <span class="o">=</span> <span class="p">[</span>
	<span class="c1"># WordEmbeddings('sv'), # uncomment to add WordEmb
</span>	<span class="n">BytePairEmbeddings</span><span class="p">(</span><span class="s">'sv'</span><span class="p">),</span>
	<span class="n">FlairEmbeddings</span><span class="p">(</span><span class="s">"sv-forward"</span><span class="p">),</span>
	<span class="n">FlairEmbeddings</span><span class="p">(</span><span class="s">"sv-backward"</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">embeddings</span><span class="p">:</span> <span class="n">StackedEmbeddings</span> <span class="o">=</span> <span class="n">StackedEmbeddings</span><span class="p">(</span><span class="n">embeddings</span><span class="o">=</span><span class="n">embedding_types</span><span class="p">)</span>

<span class="c1"># 5. initialize sequence tagger
</span><span class="n">tagger</span><span class="p">:</span> <span class="n">SequenceTagger</span> <span class="o">=</span> <span class="n">SequenceTagger</span><span class="p">(</span><span class="n">hidden_size</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
										<span class="n">embeddings</span><span class="o">=</span><span class="n">embeddings</span><span class="p">,</span>
										<span class="n">tag_dictionary</span><span class="o">=</span><span class="n">tag_dictionary</span><span class="p">,</span>
										<span class="n">tag_type</span><span class="o">=</span><span class="n">tag_type</span><span class="p">,</span>
										<span class="n">use_crf</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="training-the-model">
<a class="anchor" href="#training-the-model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Training the model</h3>
<p>Because I run through google colab and the machine can be terminated any second I run using <code class="language-plaintext highlighter-rouge">checkpoint=True</code> which means you can continue training where you left off. My models are saved to my Google Drive, real handy!</p>
<blockquote>
  <p>Pro-tip: use <code class="language-plaintext highlighter-rouge">checkpoint=True</code> in combination with Google Drive on your Google Colab.</p>
  <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1"># 7. start training
</span><span class="n">trainer</span><span class="p">.</span><span class="n">train</span><span class="p">(</span><span class="s">'drive/MyDrive/path/to/model/save/'</span><span class="p">,</span>
				<span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
				<span class="c1"># set chunk size to lower memory requirements
</span>				<span class="c1">#mini_batch_chunk_size=16,
</span>				<span class="n">mini_batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
				<span class="n">checkpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
				<span class="n">embeddings_storage_mode</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="c1"># only required for SUC 3.0 which grows too large
</span>				<span class="c1">#batch_growth_annealing=True,
</span>				<span class="c1">#anneal_with_restarts=True,
</span>				<span class="n">max_epochs</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
</code></pre></div>  </div>
  <h3 id="loading-model-from-checkpoint">
<a class="anchor" href="#loading-model-from-checkpoint" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loading model from checkpoint</h3>
  <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">trainer</span> <span class="o">=</span> <span class="n">ModelTrainer</span><span class="p">.</span><span class="n">load_checkpoint</span><span class="p">(</span><span class="s">'drive/MyDrive/path/to/model/save/checkpoint.pt'</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span>
</code></pre></div>  </div>
  <p>And that’s it!</p>
</blockquote>

<h2 id="result">
<a class="anchor" href="#result" aria-hidden="true"><span class="octicon octicon-link"></span></a>Result</h2>
<p>For me the results looks really good and close to what I expected, I had hoped that Flair would achieve at least 0.88+ F1 but 0.855 isn’t too bad. The size, speed and simplicity of Flair makes it a great contender!</p>

<table>
  <thead>
    <tr>
      <th>Dataset</th>
      <th>Size</th>
      <th>Avg F1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>klintan/swedish-ner-corpus</td>
      <td>320MB</td>
      <td>~<strong>0.89</strong>
</td>
    </tr>
    <tr>
      <td>SUC 3.0 (PER, LOC &amp; ORG)</td>
      <td>320MB</td>
      <td>~<strong>0.89</strong>
</td>
    </tr>
    <tr>
      <td>SUC 3.0 (PER, LOC, ORG, TME, MSR, …)</td>
      <td>320MB</td>
      <td><strong>0.855</strong></td>
    </tr>
    <tr>
      <td>SUC 3.0 (PER, LOC, ORG, TME, MSR, …) Quantized</td>
      <td>80MB</td>
      <td><strong>0.853</strong></td>
    </tr>
    <tr>
      <td>SUC 3.0 (PER, LOC, ORG, TME, MSR, …) w/ ALBERT</td>
      <td>50MB</td>
      <td>
<strong>0.85</strong> (via <a href="http://kth.diva-portal.org/smash/get/diva2:1451804/FULLTEXT01.pdf">KTH</a>)</td>
    </tr>
    <tr>
      <td>SUC 3.0 (PER, LOC, ORG, TME, MSR, …) w/ BERT (<a href="https://github.com/Kungbib/swedish-bert-models#bert-base-fine-tuned-for-swedish-ner">KungBib</a>)</td>
      <td>480MB</td>
      <td><strong>0.928</strong></td>
    </tr>
    <tr>
      <td>SUC 3.0 (PER, LOC, ORG, TME, MSR, …) w/ BERT Quantized</td>
      <td>120MB</td>
      <td><strong>0.928</strong></td>
    </tr>
  </tbody>
</table>

<p>I believe it’s important to note that Quantized models are also much faster running ~ 4 times faster (avg 360ms went to 80ms on a CPU for flair).<br>
Quantization updates the f32 into int8 which allows the model to more efficiently utilize CPU and the ONNX-runtime also makes the whole model better at using CPU-instructions.</p>

<h2 id="deploying-on-streamlitiosharing">
<a class="anchor" href="#deploying-on-streamlitiosharing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deploying on streamlit.io/sharing</h2>
<p>And for the final part! <img class="emoji" title=":tada:" alt=":tada:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png" height="20" width="20">
First you need a new public repository on GitHub with the streamlit &amp; model code. This requires to set up a <code class="language-plaintext highlighter-rouge">requirements.txt</code> with all necessary dependencies.</p>

<p>Then you need to figure out how you’ll host your model if it’s too large. I found GitHub LFS to work out decently, but the cap was pretty small (1GB / Month) and I broke the limit on my 3rd model. I went ahead and registered on <a href="backblaze.com">Backblaze</a> which has great reviews, but I think the best solution in my shoes would be to host it through HuggingFace Model storage (free if public!).
<strong>edit:</strong> I actually ended up storing the flair model on <a href="https://huggingface.co/londogard/flair-swe-ner">huggingface.co/londogard/flair-swe-ner</a> 🤗.</p>

<p>Setting up the script itself was quite easy for Flair.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># load tagger for POS and
</span><span class="o">@</span><span class="n">st</span><span class="p">.</span><span class="n">cache</span><span class="p">(</span><span class="n">allow_output_mutation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load_model</span><span class="p">():</span>
	<span class="n">tagger</span> <span class="o">=</span> <span class="n">SequenceTagger</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'best-model-large-data.pt'</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">tagger</span>

<span class="o">@</span><span class="n">st</span><span class="p">.</span><span class="n">cache</span><span class="p">(</span><span class="n">allow_output_mutation</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">hash_funcs</span><span class="o">=</span><span class="p">{</span><span class="n">SequenceTagger</span><span class="p">:</span> <span class="k">lambda</span>  <span class="n">_</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
	<span class="n">manual_sentence</span> <span class="o">=</span> <span class="n">Sentence</span><span class="p">(</span><span class="n">manual_user_input</span><span class="p">)</span>
	<span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">manual_sentence</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">render_ner_html</span><span class="p">(</span><span class="n">manual_sentence</span><span class="p">,</span> <span class="n">wrap_page</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="n">tagger</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">()</span>

<span class="n">st</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Swedish Named Entity Recognition (NER) tagger"</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="n">subheader</span><span class="p">(</span><span class="s">"Created by [Londogard](https://londogard.com) (Hampus Londögård)"</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Please type something in the box below"</span><span class="p">)</span>
<span class="n">manual_user_input</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">text_area</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">manual_user_input</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
	<span class="n">sentence</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">tagger</span><span class="p">,</span> <span class="n">manual_user_input</span><span class="p">)</span>
	<span class="n">st</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"Below is your tagged string."</span><span class="p">)</span>
	<span class="n">st</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">sentence</span><span class="p">,</span> <span class="n">unsafe_allow_html</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>
<p>It’s important to note how I’ve placed the caching solution. I both cache the model loading &amp; predictions to keep it as speedy as possible.</p>

<p>The <code class="language-plaintext highlighter-rouge">allow_output_mutation</code> option skips hashing the output to validate that the cache is correct, we don’t care if output has been modified really.</p>

<p>The <code class="language-plaintext highlighter-rouge">hash_funcs={SequenceTagger: lambda  _: None}</code> is <strong>incredibly important</strong>. <br>
The flair model are pretty slow to hash, especially if quantized. It’s possible to use <code class="language-plaintext highlighter-rouge">id</code> which is a unique ID for the python object that lasts the full lifetime, but because I know that the model wont change I simply use <code class="language-plaintext highlighter-rouge">lambda _: None</code> to not do any lookup at all.<br>
If the model input would change in-between using <code class="language-plaintext highlighter-rouge">id</code> is the best approach. Note that neither of this approaches are any good if you wanna compare an object to another (e.g. two string inputs), there we should just keep standard hashing.</p>

<h2 id="outro">
<a class="anchor" href="#outro" aria-hidden="true"><span class="octicon octicon-link"></span></a>Outro</h2>
<p>I trained Flair embeddings which is a much simpler approach than Transformers and achieved almost SotA while having a much smaller &amp; simpler model (~2/3rd of the size). But in the end I was very impressed by how well quantization applies for CPU utilization so I also applied the same approach for BERT-ner by KB, where I even did a ONNX Quantization which has been shown to be even more effective than PyTorch own quantization, but then again it requires the ONNX runtime.</p>

<p>Both models are available on the same device / streamlit configuration, find them on <a href="https://londogard.com/ner">londogard.com/ner</a>.<br>
The flair model is available through HuggingFace 🤗 through the following: <a href="https://huggingface.co/londogard">londogard (huggingface.co)</a>.</p>

<p>Thanks for this time,
Hampus Londögård @ Londogard</p>

  </div>
<!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js" repo="londogard/londogard" issue-term="title" label="blogpost-comment" theme="github-light" crossorigin="anonymous" async>
</script><a class="u-url" href="/nlp/machine-learning/workshop/2021/03/29/swedish-named-entity-recognition.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>A blog with a focus on Deep Learning, JVM and Performance.</p>
      </div>
    </div>

    <div class="social-links">
<ul class="social-media-list"><li><a rel="me" href="https://github.com/londogard" title="londogard"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
