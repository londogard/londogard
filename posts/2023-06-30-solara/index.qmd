---
title: "Solara - 'A new Reactive Streamlit'"
description: "Solara is fresh and exciting, to me it seems to have more industrial potential than streamlit. In this post Iâ€™ll introduce solara and compare it to the more well known streamlit that can be used to build web apps and interactive Data Dashboards."
categories: [data, dashboard, webapp]
date: "2023-06-30"
---

Solara ([solara.dev](https://solara.dev/)) is fresh and exciting, to me it seems to have more industrial potential than streamlit ([streamlit.io](https://streamlit.io/)). In this post Iâ€™ll introduce solara and compare it to the more well known streamlit that can be used to build web apps and interactive Data Dashboards.

I'm very excited to see where it ends up in the future, very possibly in a bright spot. During my initial tests it seems like a solid framework, there's still some edges to fix but all in all it's really good!  

Here's my quick introduction and comparison with streamlit!


### Streamlit and why itâ€™s awesome

Iâ€™m a huge streamlit fan. Thereâ€™s so much to love, the first time I tried it everything clicked. Itâ€™s simple and good looking, the User Experience (UX) and Developer Experience (DX) is exceptional. Using it I can easily build beautiful web apps, efficient Data Dashboards and small Proof-of-Concepts (PoC).


With that said everything has a drawback, and streamlitâ€™s is performance once it scales to large. Streamlit works by rerunning everything in the script top-down once a change happens in the webapp. This makes it incredibly simple to reason about and reduces the number of bugs, but it also builds what can become a huge bottleneck and slow down the app.Â 

Streamlit solves this by introducingÂ `cache`Â  which allows reusing results from expensive computations and in the UI they reuse components to make the flow smother if nothing changes, this is done using the internalÂ `state`. Once you start modifyingÂ `state`Â  andÂ `cache`Â the complexity grows quickly and the app becomes much harder to reason about.
  

Streamlit could solve this by enabling better APIâ€™s which allows better â€œdata-flowâ€ choices, like theÂ `st.form`Â  enables non-recalculated views unless submitted.
  

For now though... Letâ€™s tryÂ **`solara`**Â a new exciting framework which does exactly this, but without the same simplicity.

  

### Solara Introduction

Solara is a similar framework to streamlit, but rather than rerunning everything top-down every time it uses a reactive approach throughÂ `reacton`Â ([github.com/widgetti/reacton](https://github.com/widgetti/reacton)) that is a pure Python port of React toÂ `ipywidgets`.

This means that only components that are using the reactive variable is rerun, which is very exciting! The performance improvements becomes great at the cost of a more declarative state-handling.

In streamlit state is handled for you, in Solara state is separated from the component, like react, which means you handle it explicitly and further reduce hidden magic that in the end sometimes leads to a fragile complex app as the app grows.  
[shiny.rstudio.com](https://shiny.rstudio.com/py/docs/comp-streamlit.html#streamlit-requires-rewriting) shares examples of how complex state-handling can become in `streamlit`. What cannot be shared easily is how badly this scales with app size and complexity. The global state can, and probably sometimes will, lead to hard-to-find bugs and a hard time to achieve high-performant apps.

An example app and deeper introduction can be found in a later section.

## ğŸ¥ŠSolara versus Streamlit

In here Iâ€™ll compare solara and streamlit, for a more in-depth usage see later sections.

### TL;DR

Code is on GitHubÂ [lundez/solara_app](https://github.com/Lundez/solara_app) / @sec-appendix, and I added suggested improvements viaÂ [PR#180](https://github.com/widgetti/solara/pull/180)Â andÂ [Issue#177](https://github.com/widgetti/solara/issues/177)Â to solara.

- **Con**Â Higher learning curve (floor) as you handle state manually (no magic), but with better DX I see it beating streamlit because of the higher ceiling that brings new possibilities.
    - **Pro**Â Bonus: we learn the react paradigm which is widely used in frontend! A win-win for developers.
- **Pro**Â A better industrial thinking
    1. Testing is actually handled E2E by usingÂ `playwright`Â  â€“Â [docs](https://solara.dev/docs/howto/testing).
    2. Routing is first-class citizen â€“Â [docs](https://solara.dev/docs/understanding/routing).
    3. Embeddable, in flask/fastAPI/... â€“Â [docs](https://solara.dev/docs/deploying/self-hosted).
- **Con**Â UX is not as good as streamlit.
- **Pro**Â Embeddable in Notebooks making it simpler to goÂ _really fast_.
- **Pro**Â Access to allÂ `ipywidgets`Â which is an incredible ecosystem.Â 

  

Additionally compared to another interesting framework likeÂ [Panel](https://panel.holoviz.org/ "https://panel.holoviz.org/")Â itâ€™s much simpler IMO.

  

Most certainly solara has a bright future if the development and maintenance is kept up, with additional marketing it can become a great competitor in the space for Gradio, Streamlit and others.

  

## Solara Introduction  

All code is available on GitHubÂ [lundez/solara\_app](https://github.com/Lundez/solara_app "https://github.com/Lundez/solara_app") and @sec-appendix.

  

### A simple app

Using solara to build a simple app is pretty clean, we can clearly see theÂ `react`Â -hook being used forÂ `file`Â  which is cool!

The entry-point in Solara is defined as a `component` named `Page`, this is automatically picked up and rendered. To show in a notebook you simply useÂ `display(Page())`.Â 

```python
import solara
import polars as pl

@solara.component
def Page():
    file, set_file = solara.use_state(None)
    solara.Markdown("# Solara Example App (Starbucks Data)")
    solara.FileDrop(on_file=set_file, lazy=False)
    if file is not None:
        df = pl.read_csv(file["data"], null_values="-").drop_nulls()
        solara.DataFrame(df.to_pandas()) # currently does not support polars
    else:
        solara.Text("Make sure to upload a file")
```

  

And run it through

```bash
solara run app.py
# use solara run --host localhost app.py on WSL until PR#180 or other is merged
```

  

Quite simple right? And incredibly similar to how you run streamlit ğŸ˜‰.

  

### Working more with state

In the previous code we only used the state inside the same component, thatâ€™s all fine but itâ€™s not a very good use-case.

Solara introduces 2 other types of state,Â `reactive`Â  andÂ `use_reactive`. Both very similar butÂ `use_reactive`Â  is only possible to use locally inside aÂ `component`. TheÂ `reactive`Â function should only be used outside of components, for application wide state. If you use it inside a `component` it'll be reset as the re-render happens, which is not what you'd expect.

As such we define aÂ `reactive`Â  variableÂ `sodium`.

```python
sodium = solara.reactive(0)
```

further we bind this to a slider

```python
solara.SliderInt(value=sodium)
```

where itâ€™ll automatically update whenever a user changes the slider.  
We can then send this to a child-component which would be updated as well when itâ€™s changed.

```python
ChildPage(sodium)
```

SeeÂ [lundez/solara\_app](https://github.com/Lundez/solara_app "https://github.com/Lundez/solara_app")Â to get a little more complex scenario.

And thatâ€™s my quick and dirty introduction to Solara!

## Solara and Streamlit comparison

A comparison between the two is available in @sec-appendix, where I use multiple components and share state between them. If you add some logging you can see that **Solara doesn't rerun code that doesn't need to**.

### Quick Facts

|     |     |     |
| --- | --- | --- |
| Measurement | Solara | Streamlit |
| #lines of code (LOC) | 53  | **49** |
| Simplicity (0-5) | 3   | **4** |
| Performance (0-5) | **4** | 3   |
| UX (0-5) - images in @sec-ux | 3   | **5** |

  
Streamlit wins most, but with the performance and possibilities of Solara I still see it as a very capable contender. With, hopefully soon, improved UX and DXÂ `solara`Â  can grow to be really big!

In the TL;DR section you can see some other nicities of Solara such as Testing, Embeddability and more!Â 

### Deeper Comparison

#### State and â€˜pythonicismâ€™

TheÂ `react`Â  paradigm while cool isÂ **certainly not pythonic**Â at all! I believe that theÂ **initial â€œPoCâ€-stage implementation should be simpler**Â to get started with. To â€œturn the knobsâ€ and squeeze performance as is possible is great and should certainly be available for the more performance intense sections.

The positive of all this is that we learn the â€œReact-paradigmâ€ and we handle state explicitly, i.e. no streamlit magic!Â 

**Itâ€™s a tie.**


#### Embeddability

The embedability of Solara is a clear winner, being able to include it in our FastAPI backend or building an app initially directly in a Jupyter Notebook is insanely good.

**Solara wins.**

#### Components / UX {#sec-ux}

Streamlits components are better and more beautiful but Solara is not far behind, and with the possibility to use all components fromÂ `ipywidget`\-ecosystem makes it incredibily powerful.

I see this as a huge boon.

##### Image Comparisons of Components

::: {layout-ncol=2}
![**Solara No File** -- bad design and too raw](assets/solara_no_file.png)

![**Streamlit No File** -- clear in both drag & select files](assets/streamlit_no_file.png)

![**Solara With File** -- we cannot remove file clearly](assets/solara_file.png)

![**Streamlit With File** -- file can be removed easily](assets/streamlit_file.png)

![**Solara Slider** -- we don't know the values](assets/solara_slider.png)

![**Streamlit Slider** -- values are clear](assets/streamlit_slider.png)

![**Solara Moving Slider** -- we now see values](assets/solara_slider_active.png)

![**Streamlit Moving Slider**](assets/streamlit_slider_active.png)

![**Solara DataFrame** -- great with defaulted pagination, no sorting though.](assets/solara_df.png)

![**Streamlit DataFrame** -- we can sort and the columns are clearly separated, it's also searchable](assets/streamlit_df.png)
:::

**Itâ€™s a small win for streamlit,**Â streamlit clearly wins the â€˜simplicityâ€™, â€˜designâ€™ and 'clearness' but solara has a bonus for the amount of widgets available through `ipywidgets` ecosystem.
  
#### Readability

BecauseÂ `solara`Â  has less magic I believe Solara is easier to reason about in a complex app, but in the PoCâ€™s and simple apps streamlit is just as simple.

**Itâ€™s a tie**, but solara wins as the app grows.


## Outro

I believe thatÂ `streamlit`Â  still is the best framework to get started with, but in 6 months from now on I can seeÂ `solara`Â  as the better option.

If youâ€™re developing a dashboard or app that needs high performance and industrial strength I can seeÂ `solara`Â  as a better choice.


Iâ€™ll happily try to help solara grow!
  

~Hampus LondÃ¶gÃ¥rd

# Appendix {#sec-appendix}

I include full code here as well. These are taken from [lundez/solara_app](https://github.com/Lundez/solara_app) the 29/6 2023.

## Solara App

Run using `solara run <filename>`.

```python
from dataclasses import dataclass
import solara
import polars as pl
import solara.express as px

@solara.component
def Page():
    file, set_file = solara.use_state(None)
    
    solara.Markdown("# Solara Example App (Starbucks Data)")
    solara.FileDrop(on_file=set_file, lazy=False)
    if file is not None:
        df = pl.read_csv(file["data"], null_values="-").drop_nulls()
        DFViews(df)
    else:
        solara.Text("Make sure to upload a file")

@dataclass
class FilterValues:
    sodium: tuple[int, int]
    carb: tuple[int, int]

@solara.component
def Filters(df: pl.DataFrame, filters: solara.Reactive[FilterValues]):
    with solara.Card("Filter DataFrame"):
        carbs = solara.use_reactive((df["Carb. (g)"].min(), df["Carb. (g)"].max()))
        sodium = solara.use_reactive((df["Sodium"].min(), df["Sodium"].max()))
        solara.SliderRangeInt("Carbs (g)", value=carbs, min=df["Carb. (g)"].min(), max=df["Carb. (g)"].max())
        solara.SliderRangeInt("Sodium", value=sodium, min=df["Sodium"].min(), max=df["Sodium"].max())
        
        with solara.CardActions():
            solara.Button("Submit", on_click=lambda: filters.set(FilterValues(sodium.value, carbs.value)))

@solara.component
def FilteredPage(df: pl.DataFrame, filter_values: solara.Reactive[FilterValues]):
    df = df.filter(pl.col("Sodium").is_between(filter_values.value.sodium[0], filter_values.value.sodium[1]) &
                   pl.col("Carb. (g)").is_between(filter_values.value.carb[0], filter_values.value.carb[1]))
    DFVis(df)

@solara.component
def DFVis(df: pl.DataFrame):
    solara.Markdown(f"## DataFrame")
    solara.DataFrame(df.to_pandas(), items_per_page=5)
    px.histogram(df, x=["Carb. (g)", "Sodium"])

@solara.component
def DFViews(df: pl.DataFrame):
    filter_values = solara.use_reactive(FilterValues((df["Carb. (g)"].min(), df["Carb. (g)"].max()), (df["Sodium"].min(), df["Sodium"].max())))
    Filters(df, filter_values)
    with solara.Columns():
            DFVis(df)
            FilteredPage(df, filter_values)
```


## Streamlit App

Run using `streamlit run <filename>`.

```python
from dataclasses import dataclass
import streamlit as st
import polars as pl
import plotly.express as px

def Page():
    st.markdown("# Streamlit Example App (Starbucks Data)")
    file = st.file_uploader("Upload a file")
    if file is not None:
        df = pl.read_csv(file, null_values="-").drop_nulls()
        DFViews(df)
    else:
        st.write("Make sure to upload a file")

@dataclass
class FilterValues:
    sodium: tuple[int, int]
    carb: tuple[int, int]

def Filters(df: pl.DataFrame) -> FilterValues:
    with st.form("df_filer"):
        st.write("**Filter DataFrame**")
        carbs = (df["Carb. (g)"].min(), df["Carb. (g)"].max())
        sodium = (df["Sodium"].min(), df["Sodium"].max())
        carbs = st.slider("Carb. (g)", min_value=carbs[0], max_value=carbs[1], value=carbs)
        sodium = st.slider("Sodium", min_value=sodium[0], max_value=sodium[1], value=sodium)
        
        st.form_submit_button("Submit")
    return FilterValues(sodium, carbs)

def FilteredPage(df: pl.DataFrame, filter_values: FilterValues):
    df = df.filter(pl.col("Sodium").is_between(filter_values.sodium[0], filter_values.sodium[1]) &
                   pl.col("Carb. (g)").is_between(filter_values.carb[0], filter_values.carb[1]))
    DFVis(df)

def DFVis(df: pl.DataFrame):
    st.markdown(f"## DataFrame")
    st.dataframe(df.to_pandas())
    st.write(px.histogram(df, x=["Carb. (g)", "Sodium"]))

def DFViews(df: pl.DataFrame):
    filters = Filters(df)
    c1, c2 = st.columns(2)
    with c1:
        DFVis(df)
    with c2:
        FilteredPage(df, filters)

Page()
```