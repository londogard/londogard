## Solara, League of Legends and Deep Learning to extract E-Sport Highlights

Hi all! üëã

I'm back with a New Years Resolution to release at least 6 blogs in 2024, focusing on interesting content that‚Äôs unique and not simple click-bait.

Today I'm sharing the continuation of a presentation I did at Foo Caf√©. I have built a complex yet user-friendly *Data App* using [*solara*](https://solara.dev/ "https://solara.dev/").

There's two partd that creates this complexity.

1.  **Heavy processing** that requires threading

    -   Deep Learning & ffmpeg processing

2.  **Multi-stage app**¬†that requires state

    -   This will be clear when you view the video of the app

My presentation at Foo Caf√© focused more on the training process and exploring option to deploy my tool. This blog rather focuses on the Data App itself! üöÄ

### Quick Backstory

My kid brother asked me to help him earn some quick bucks through automating a process to build highlight-videos of E-Sports to upload on YouTube. The emphasis was on a single streamer,¬†TheBausFFS who's a famous Swedish streamer in League of Legends (LoL). When I set out my¬†brother had hope to earn cash and I to learn new tools and assist my family with my deep knowledge. üí™

## Choices during my Journey

I was contemplating three (3) options to deploy my resulting model.

+------------------+--------------------------------------------+-----------------------------------------------------------------------------+
| Tool             | Pro                                        | Con                                                                         |
+==================+============================================+=============================================================================+
| Streamlit        | -   (I'm) Experienced                      | -   Doesn't support the dynamic nature of app without extreme state hacking |
|                  |                                            |                                                                             |
|                  | -   Beautiful                              |                                                                             |
|                  |                                            |                                                                             |
|                  | -   Simple                                 |                                                                             |
+------------------+--------------------------------------------+-----------------------------------------------------------------------------+
| Solara           | -   React Data Flow, supports our use-case | -   Uglier                                                                  |
|                  |                                            |                                                                             |
|                  | -   Complexity grows logarithmically       | -   I'm in-experienced                                                      |
|                  |                                            |                                                                             |
|                  |                                            | -   It's the "new kid on the block"                                         |
+------------------+--------------------------------------------+-----------------------------------------------------------------------------+
| Jupyter Notebook | -   Easy GPU                               | -   Not User-Friendly (for non-tech persons)                                |
|                  |                                            |                                                                             |
|                  |                                            | -   Not as dynamic/stateful as needed (i.e. everything is a flow)           |
+------------------+--------------------------------------------+-----------------------------------------------------------------------------+
| Gradio           | -   Simple                                 | -   Complexity grows exponentially                                          |
+------------------+--------------------------------------------+-----------------------------------------------------------------------------+

Other tools such as Panel was considered and rejected due to time and non-composability. For technical details such as model and more see my previous [blog](../2023-09-10-highlights-lol)

### Result

What did the whole process net me?

1.  Intimate knowledge about *Solara* and complex *Data Apps* that require high performance and efficiency.

2.  Insights in *Video Classification* and how it differentiates from *Image Classification.*

3.  Experimentation in providing *Data Apps*¬†to non-domain-experts that have no technical expertise nor willingness to learn new things.

All of this resulted in a Solara Data App that doesn't look shit and is smooth to use thanks to state management and threading.

The resulting code covers most of the building blocks required to build everything from¬†basic to complex Data Apps!

# App show case

## Implementation

See blog X for model training.

### Building Progress Loaders in Solara

I created a component to wrap Progress on top of the `use_thread`¬† returned `solara.Result`¬† class.

``` python
@solara.component()
def ProgressDynamic(
    msg: str,
    result: solara.Result[Any],
):
    if result.state == solara.ResultState.RUNNING:
        Progress(msg)
```

This is a quite simple class, yet it cleans up a lot of code when called like:

``` python
res = write_video.use_thread(
    tstamp["start"],
    tstamp["end"],
    selected_vid,
    Path(file_name).stem,
)
Progress("Building Clip...", res)
```

![Resulting spinner on loads](Files/image.png)

### Checkpointing / State Management and Parent/Children (Hierarchy)

State is managed through `solara.reactive`¬† variables, this enables a quite clean UI. It becomes very clean using hierarchy, like in React. State trickles up and down.

#### Trickle Down to Child

``` python
@solara.component
def CutOffChartSelection(
    cut_off: solara.Reactive[int],
    df: pl.DataFrame,
): # this method is simplified to show-case important parts.
    div = solara.Column()
    solara.SliderInt(
        "Highlight Y-Cutoff",
        cut_off,
        min=df["preds"].min() + 1,
        max=df["preds"].max(),
        thumb_label="always",
        tick_labels="end_points",
    )
    with div:
        fig = px.line(df, x="timestamp", y="preds", line_shape="hv")
        fig.add_hline(y=cut_off.value, line_color="red")
        solara.FigurePlotly(fig)
```

What‚Äôs important here?

1.  Note how I set `div = solara.Column()`¬† this lets me re-order UI and disregard execution flow.¬†
2.  Note `cut_off`¬† is `solara.Reactive`, whenever this is updated in parent the child will be updated additionally. And the reverse is also true.

#### Trickle Up to Parent

``` python
@solara.component
def ModelFileSelectComponent(
    file: solara.Reactive[str],
    model: solara.Reactive[str],
):
    files = ...
    models = ...
    with solara.Card("Select Video/Model"):
        with solara.Columns():
            solara.Select("Select File", values=files, value=file)
            solara.Select("Select Model", values=models, value=model)
```

In this component we can see that we insert `file: solara.Reactive`¬† which is edited through the `solara.Select`. This creates a clean trickle-up flow and allow us to hide details.

> ‚ö†Ô∏è It would be even cleaner if our component could return this reactive variable, rather than declaring it in parent.

### Threading to improve UI experience

When working with UI it‚Äôs important to not block the main thread, sometimes called rendering thread.¬† 
**Why?**¬†Because if you block the thread everything is ‚Äúfrozen‚Äù in an awkward state, no progress or anything for the user.  
**How**¬†is it solved? Using threads. Fortunately in solara it‚Äôs simple to apply threading through two choices.

``` python
# 1. Memoized function
@solara.memoize
def slow_func(...): ...
result = slove_func.use_thread(...)
# 2. Run thread directly
def slow_func_2(...): ...
result = solara.use_thread(lambda: slow_func_2(...), dependencies=...)
```

Applying either returns a `solara.Result`¬† class, which will be updated during progress of the function and can be parsed by looking at `result.state`¬† which is among other things `solara.ResultState.RUNNING`¬† and `solara.ResultState.FINISHED`.

This creates a smooth experience for the end-user, alas it‚Äôs not perfect for the developer themself. I often end up with the following, almost anti-pattern, of if-elses:

``` python
res = write_video.use_thread(...)
if res.state == solara.ResultState.RUNNING:
    Progress("Writing video...")
elif res.state == solara.ResultState.FINISHED:
    show_finished_ui(...)
```

One time not time, but I have this written in multiple places of the app and the flow itself feels cumbersome. I‚Äôm looking into how I can help solara fix the situation. **All in all it‚Äôs a good experience to include threading though, something unimaginable in Streamlit!**

### Plotly Callbacks

I‚Äôve implemented a really cool Plotly Callback through the relayout, allowing a person to select a subset of the video by ‚Äúzooming‚Äù/‚Äùdragging‚Äù. It‚Äôs a smooth approach to selecting sub-parts of videos to build the full video, i.e. one game at a time and not the full stream!

``` python
def update_vals(relayout_dict: dict[str, Any] | None):
    if relayout_dict is not None:
        layout = relayout_dict["relayout_data"]
        start_stop.value = [
            parser.parse(layout["xaxis.range[0]"], ignoretz=True),
            parser.parse(layout["xaxis.range[1]"], ignoretz=True),
        ]
solara.FigurePlotly(fig, on_relayout=update_vals)
```

{{< video Files/full_app_use.mp4 >}}

# Videos

## Using App Simple
{{< video Files/using_app_simple.mp4 >}}

## Full Use Button
{{< video Files/full_vid_btn.mp4 >}}

Run application¬†

1. *podman* (Docker) container to make deployment simple
2. *Micromamba env*

### Findings

1.  React state enables almost impossible things from Streamlit, like modifying a list of values one by one
    -   Would require modifying streamlite.state which is very hacky!
2.  Even if it‚Äôs easier to separate UI and Code it‚Äôs still easy to end up with a messy code like streamlit. 

# Appendix 


## Issues in Solara
-   Sync to updated filestorage (i.e. downloading Twitch movies, I even tried reloading reactive variable)
    -   ¬†I solved this by not using tabs, to have the user "refresh" site by changing page. 

## App Run

## Python Dev Setup

Recommended setup for developer. 

1. `‚Å†.vscode/settings.json`
2. `pre-commit.yml` 
3. `‚Å†.devcontainer`
4. `Dockerfile`
5. `env.yml`