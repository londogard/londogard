"use strict";(self.webpackChunklondogard=self.webpackChunklondogard||[]).push([[4541],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),h=s(n),u=i,c=h["".concat(p,".").concat(u)]||h[u]||d[u]||o;return n?a.createElement(c,l(l({ref:t},m),{},{components:n})):a.createElement(c,l({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=h;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var s=2;s<o;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},745:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return p},metadata:function(){return s},assets:function(){return m},toc:function(){return d},default:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),l=["components"],r={description:"A three part blog (all included in this one) that goes through 1) How Kotlin Multiplatform works, 2) How to build a game (Snake) and finally 3) how to make it multiplatform.",tags:["gradle","kotlin","workshop","multiplatform"],title:"How to build and play Snake via Native Binary, JVM and JS/Browser (Kotlin)",authors:"hlondogard"},p=void 0,s={permalink:"/blog/2020/11/07/snake-kotlin-multiplatform",editUrl:"https://github.com/londogard/londogard/blog/2020-11-07-snake-kotlin-multiplatform.md",source:"@site/blog/2020-11-07-snake-kotlin-multiplatform.md",title:"How to build and play Snake via Native Binary, JVM and JS/Browser (Kotlin)",description:"A three part blog (all included in this one) that goes through 1) How Kotlin Multiplatform works, 2) How to build a game (Snake) and finally 3) how to make it multiplatform.",date:"2020-11-07T00:00:00.000Z",formattedDate:"November 7, 2020",tags:[{label:"gradle",permalink:"/blog/tags/gradle"},{label:"kotlin",permalink:"/blog/tags/kotlin"},{label:"workshop",permalink:"/blog/tags/workshop"},{label:"multiplatform",permalink:"/blog/tags/multiplatform"}],readingTime:24.79,truncated:!0,authors:[{name:"Hampus Lond\xf6g\xe5rd",title:"Main Contributor of Londogard",url:"https://github.com/lundez",imageURL:"https://github.com/lundez.png",key:"hlondogard"}],frontMatter:{description:"A three part blog (all included in this one) that goes through 1) How Kotlin Multiplatform works, 2) How to build a game (Snake) and finally 3) how to make it multiplatform.",tags:["gradle","kotlin","workshop","multiplatform"],title:"How to build and play Snake via Native Binary, JVM and JS/Browser (Kotlin)",authors:"hlondogard"},prevItem:{title:"Transfer Learning (Presentation)",permalink:"/blog/2020/12/12/transfer-learning-presentation"},nextItem:{title:"TIL: SDKMan - The Software Development Kit Manager",permalink:"/blog/2020/09/04/til-sdkman"}},m={authorsImageUrls:[void 0]},d=[{value:"LLVM",id:"llvm",children:[],level:2},{value:"How the Kotlin Compiler works, Frontend to Backend",id:"how-the-kotlin-compiler-works-frontend-to-backend",children:[{value:"The Kotlin Compiler Frontend",id:"the-kotlin-compiler-frontend",children:[],level:3},{value:"The Kotlin Compiler Backend",id:"the-kotlin-compiler-backend",children:[],level:3}],level:2},{value:"How Kotlin keeps multiplatform clean",id:"how-kotlin-keeps-multiplatform-clean",children:[],level:2},{value:"Summarizing how Multiplatform works",id:"summarizing-how-multiplatform-works",children:[],level:2},{value:"Outro: Kotlin Multiplatform and why it matters",id:"outro-kotlin-multiplatform-and-why-it-matters",children:[],level:2},{value:"Building a JVM App (Snake)",id:"building-a-jvm-app-snake",children:[{value:"Drawing the snake &amp; apple",id:"drawing-the-snake--apple",children:[],level:3},{value:"Creating the data structures",id:"creating-the-data-structures",children:[{value:"Adding a Direction",id:"adding-a-direction",children:[],level:4}],level:3}],level:2},{value:"Wrapping up the code with some minor refactoring / new functionality",id:"wrapping-up-the-code-with-some-minor-refactoring--new-functionality",children:[],level:2},{value:"JS/Browser target",id:"jsbrowser-target",children:[],level:2},{value:"Native target",id:"native-target",children:[],level:2}],h={toc:d};function u(e){var t=e.components,n=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"A three part blog (all included in this one) that goes through "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"How Kotlin Multiplatform works (compiler and everything)"),(0,o.kt)("li",{parentName:"ol"},"How to build a game (Snake) and finally "),(0,o.kt)("li",{parentName:"ol"},"how to make it multiplatform.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"All the code is available ",(0,o.kt)("a",{parentName:"strong",href:"https://github.com/londogard/snake-js-jvm-native"},"here"),".")),(0,o.kt)("p",null,"It's highly recommended using IntelliJ, a free (community) edition can be downloaded from ",(0,o.kt)("a",{parentName:"p",href:"https://www.jetbrains.com/idea/download/#section=windows"},"jetbrains.com"),".",(0,o.kt)("br",{parentName:"p"}),"\n","It's also required that your Kotlin version is above 1.4 (some huge Multiplatform changes was added in release 1.4)."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Disclaimer:")," this post is pretty long and I recommend reading one part at a time (it's 3 parts)."),(0,o.kt)("p",{parentName:"blockquote"},"Personally I hate unfinished blogs that are multiple parts, hence I uploaded all at once. So be assured, you're getting all parts - right here, right now! :happy:"),(0,o.kt)("p",{parentName:"blockquote"},"Finally, the first part is purely informational about how everything works and the second part is how to actually code the game. The second part is interactive and contains a lot of TODOs.\nThe third, and final, part covers how we are able to use the same code on JS/Browser & Native")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"All the finished code is available ",(0,o.kt)("a",{parentName:"strong",href:"https://github.com/londogard/snake-js-jvm-native/tree/completed_project"},"here"))," (open ",(0,o.kt)("inlineCode",{parentName:"p"},"master")," if you wish to have the unfinished code)."),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"First off, what is Kotlin?"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://lh6.googleusercontent.com/z07YTS2Ft_HypvBzChXpX4L1ye3y4ht0x142UCo8q6LGT0EaxZyEFA5hwP3_OV4ZQafkavgMBtRBP3X6RFPpogLTG5uR8J485-o6y1TOZ3xh_7TZkvTb7DOSGqIm5kiIZwPFCZdlLXg",alt:null})),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Image from ",(0,o.kt)("a",{parentName:"p",href:"https://kotlinlang.org/"},"kotlinlang.org"))),(0,o.kt)("p",null,"By my own account it's a language that has learned from many mistakes done in the past and tries to extend and embrace the good ones!"),(0,o.kt)("p",null,'The most obvious one solved by Kotlin is "The Billion Dollar Mistake" as the inventor ',(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tony_Hoare"},"Tony Hoare")," calls it himself, namely ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),". Kotlin is not alone about this, but certainly off to a good start!"),(0,o.kt)("p",null,"Some mentionable features on top of this is"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://kotlinlang.org/docs/reference/coroutines-overview.html"},"Coroutines"),' - A more efficient (lightweight) threading model, also called "green threads" sometimes. Feels very natural and easy.'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://kotlinlang.org/docs/reference/data-science-overview.html"},"Data-Science & Jupyter")," support"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://kotlinlang.org/docs/reference/extensions.html#extensions"},"Extension functions")," - Perhaps my favourite feature, do you feel a class is missing a function? No problem, you're free to do so!"),(0,o.kt)("li",{parentName:"ul"},"Excellent ",(0,o.kt)("a",{parentName:"li",href:"https://kotlinlang.org/spec/type-inference.html"},"typing")," - Perhaps not Scala, but still very good."),(0,o.kt)("li",{parentName:"ul"},"& more!")),(0,o.kt)("p",null,"All of this is available through Kotlins Multiplatform effort, where Multiplatform does not mean Mac/Windows/Linux but rather that we can compile into different platforms such as Java Bytecode (JVM), ",(0,o.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/native-overview.html"},"Native"),"  and ",(0,o.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/js-overview.html"},"JS/Browser"),"."),(0,o.kt)("p",null,"Enough praises, let's get onto how the multiplatform solution actually works through ","[",(0,o.kt)("strong",{parentName:"p"},"Part 1"),"]","(#Part 1: How does Kotlin Multiplatform work)."),(0,o.kt)("h1",{id:"part-1-how-does-kotlin-multiplatform-work"},"Part 1: How does Kotlin Multiplatform work?"),(0,o.kt)("p",null,"Let's begin by understanding exactly what ",(0,o.kt)("strong",{parentName:"p"},"Native")," is?\nFrom the landing page of ",(0,o.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/native-overview.html"},"kotlinlang.org/native"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an  ",(0,o.kt)("a",{parentName:"p",href:"https://llvm.org/"},"LLVM"),"  based backend for the Kotlin compiler and native implementation of the Kotlin standard library.")),(0,o.kt)("p",null,"This statement tells us a few things, such as ",(0,o.kt)("em",{parentName:"p"},"native")," refering to binary executables that can run on a OS (natively) using no virtual machine or browser!",(0,o.kt)("br",{parentName:"p"}),"\n","But in practice?"),(0,o.kt)("p",null,"\u2714\ufe0f Small file size",(0,o.kt)("br",{parentName:"p"}),"\n","\u2714\ufe0f No overhead",(0,o.kt)("br",{parentName:"p"}),"\n","\u2714\ufe0f Incredibly fast starting-time"),(0,o.kt)("p",null,"As usual it isn't a win-win situation but you loose some"),(0,o.kt)("p",null,"\u274cDevelopment speed    "),(0,o.kt)("h2",{id:"llvm"},"LLVM"),(0,o.kt)("p",null,"LLVM is probably the biggest project (compiler) that exists to build native binaries. Languages such as C, C++, Haskell, Rust & Swift compile into native binaries through LLVM."),(0,o.kt)("p",null,"From the info-box previously,"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"It is an  ",(0,o.kt)("a",{parentName:"strong",href:"https://llvm.org/"},"LLVM"),"  based backend for the Kotlin compiler")," and native implementation of the Kotlin standard library.")),(0,o.kt)("p",null,"So... What is a backend? More specifically, what is a backend for a compiler?"),(0,o.kt)("h2",{id:"how-the-kotlin-compiler-works-frontend-to-backend"},"How the Kotlin Compiler works, Frontend to Backend"),(0,o.kt)("p",null,"A compiler is like a translator, just as you'd translate Swedish into English a compiler instead translates computer code written in one programming language into another one of lower level, e.g. assembly. "),(0,o.kt)("p",null,"In general all compilers follow the same pattern, and Kotlin is no different. Even though it's a similar path it's interesting to learn about, even more if you don't know how it usually works!",(0,o.kt)("br",{parentName:"p"}),"\n","The Kotlin Compiler first compiles Kotlin code into a ",(0,o.kt)("em",{parentName:"p"},"Intermediate Representation"),", or ",(0,o.kt)("em",{parentName:"p"},"IR"),", which it later turns into Java Bytecode, when targeting the ",(0,o.kt)("em",{parentName:"p"},"Java Virtual Machine")," (",(0,o.kt)("em",{parentName:"p"},"JVM"),"). "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/97027300-d2095900-155a-11eb-9d18-6fb58a0a9699.png",alt:"image"})),(0,o.kt)("p",null,"The first part is called the ",(0,o.kt)("strong",{parentName:"p"},"Compiler Frontend")," "),(0,o.kt)("h3",{id:"the-kotlin-compiler-frontend"},"The Kotlin Compiler Frontend"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/97027463-1137aa00-155b-11eb-9c31-a60e3e25af87.png",alt:"image"})),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"Compiler Frontend")," turns the Kotlin code into a ",(0,o.kt)("em",{parentName:"p"},"Intermediate Representation")," of the code which is represented by a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree"},"abstract syntax tree"),". The ",(0,o.kt)("em",{parentName:"p"},"abstract syntax tree")," in turn is built from concrete syntax, e.g. strings.",(0,o.kt)("br",{parentName:"p"}),"\n","The process involves ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lexical_analysis"},"lexical analysis")," which creates tokens and pass it forward to the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Parsing"},"parser")," that finally builds the ",(0,o.kt)("em",{parentName:"p"},"abstract syntax tree"),".",(0,o.kt)("br",{parentName:"p"}),"\n","For those interested this could be a really fun challenge and learning lesson to implement yourself!"),(0,o.kt)("p",null,"Moving on, the second and final part is called the ",(0,o.kt)("strong",{parentName:"p"},"Compiler Backend"),"."),(0,o.kt)("h3",{id:"the-kotlin-compiler-backend"},"The Kotlin Compiler Backend"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/97077672-ddee2d00-15e5-11eb-9f71-916c5b2a0544.png",alt:"image"})),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"Compiler Backend")," turns this abstract syntax tree, or ",(0,o.kt)("em",{parentName:"p"},"IR"),", into computer output language.",(0,o.kt)("br",{parentName:"p"}),"\n","In the image that is Java Bytecode which is understood by the ",(0,o.kt)("em",{parentName:"p"},"JVM"),". The backend is the part that actually optimize code to remove for-loops where applicable, exchange variables into constants and so on.",(0,o.kt)("br",{parentName:"p"}),"\n","Just as with the frontend it's a really good challenge to either implement a backend without optimizations, or focus on a existing one and adding a optimization yourself!"),(0,o.kt)("p",null,"What is interesting about Kotlin is that it has different compiler backends, which means that the ",(0,o.kt)("em",{parentName:"p"},"IR")," compile not only into Java Bytecode but also JS/Browser & Native binaries. "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/97077776-b8155800-15e6-11eb-8ae6-a83a77253087.png",alt:"image"})),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side-note"),": For Native Backend there's in fact two ",(0,o.kt)("em",{parentName:"p"},"Intermediate Representations"),", first Kotlin ",(0,o.kt)("em",{parentName:"p"},"IR")," which then compiles into LLVM ",(0,o.kt)("em",{parentName:"p"},"IR"),". LLVM finally turns this into a native binary through its own Compiler Backend.",(0,o.kt)("br",{parentName:"p"}),"\n","During the final step in LLVM all the optimizations applied to C, C++, Swift & many more is also applied to Kotlin Native code!")),(0,o.kt)("h2",{id:"how-kotlin-keeps-multiplatform-clean"},"How Kotlin keeps multiplatform clean"),(0,o.kt)("p",null,"It might sound messy to target multiple platforms like this, and how could it possibly end up clean?"),(0,o.kt)("p",null,"By using the standard libraries that are included with Kotlin, which includes almost everything you need, and multiplatform-developed community libraries, e.g. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cashapp/sqldelight"},"SQLDelight"),", you get code that looks the same and works the same irregardless of target (JS/Browser, Native or the JVM)."),(0,o.kt)("p",null,"To give an example of how Kotlin std-lib works, let's take one of the most common types - ",(0,o.kt)("inlineCode",{parentName:"p"},"String"),". "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/97077938-2dcdf380-15e8-11eb-8282-873d80f6178e.png",alt:"image"})),(0,o.kt)("p",null,"By using ",(0,o.kt)("inlineCode",{parentName:"p"},"Kotlin.String")," rather than the usual ",(0,o.kt)("inlineCode",{parentName:"p"},"Java.lang.String")," you do when programming Java you get a type that works on multiple platforms, including some awesome convenience functions. Imagine, you can write native code using ",(0,o.kt)("inlineCode",{parentName:"p"},".substring"),", ",(0,o.kt)("inlineCode",{parentName:"p"},".take(n)")," & ",(0,o.kt)("inlineCode",{parentName:"p"},".replace")," - amazing compared to ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," right? :happy:"),(0,o.kt)("p",null,"To put this in context of the compiler, this means that the ",(0,o.kt)("em",{parentName:"p"},"Compiler Backend")," automatically maps the ",(0,o.kt)("em",{parentName:"p"},"IR")," of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Kotlin.String")," into the correct type."),(0,o.kt)("p",null,"You can take this concept and apply to anything such as IO , network & more - all which are included in the std-lib! "),(0,o.kt)("h2",{id:"summarizing-how-multiplatform-works"},"Summarizing how Multiplatform works"),(0,o.kt)("p",null,"Let's recollect what we've gone through"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Kotlin Compiler compiles Kotlin code into a ",(0,o.kt)("em",{parentName:"li"},"Intermediate Representation")," (IR) through the ",(0,o.kt)("em",{parentName:"li"},"Compiler Frontend"),".",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("em",{parentName:"li"},"IR")," is a abstract syntax tree."))),(0,o.kt)("li",{parentName:"ol"},"Kotlin Compiler then goes the ",(0,o.kt)("em",{parentName:"li"},"Compiler Backend")," which turns the code into the lower level language, e.g. Java Bytecode, and applies multiple optimisations."),(0,o.kt)("li",{parentName:"ol"},"Kotlin has a std-lib which has functionalities as ",(0,o.kt)("inlineCode",{parentName:"li"},"Kotlin.String"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Kotlin.List"),", networking and much more.",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Kotlin.String")," turns into ",(0,o.kt)("inlineCode",{parentName:"li"},"KString")," in the case of targeting ",(0,o.kt)("em",{parentName:"li"},"Native"),". ",(0,o.kt)("inlineCode",{parentName:"li"},"KString")," is Kotlins own native strings with some cool helper methods.")))),(0,o.kt)("p",null,'Native is usually considered "dangerous" and "hard" because of all the quirks like pointers, address space and other.'),(0,o.kt)("p",null,"Kotlin Native deals with ",(0,o.kt)("em",{parentName:"p"},"memory allocation")," in the same way as Swift, namely ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reference_counting"},(0,o.kt)("em",{parentName:"a"},"reference counting"))," which deallocates objects once they've got no references. There's some advantages such as being really fast, but also downsides such as ",(0,o.kt)("em",{parentName:"p"},"reference cycles")," which it handles poorly when compared to the JVM Garbace Collector (GC)."),(0,o.kt)("p",null,"Kotlin also has some really nice convenience syntax such as the ",(0,o.kt)("inlineCode",{parentName:"p"},"memScope"),"-block."),(0,o.kt)("h2",{id:"outro-kotlin-multiplatform-and-why-it-matters"},"Outro: Kotlin Multiplatform and why it matters"),(0,o.kt)("p",null,"\u2714\ufe0f One code-base for common logic  "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Serialization logic, e.g. parsing JSON into a data class"),(0,o.kt)("li",{parentName:"ul"},"Networking"),(0,o.kt)("li",{parentName:"ul"},"Database  ")),(0,o.kt)("p",null,"\u2714\ufe0f Development speed",(0,o.kt)("br",{parentName:"p"}),"\n","\u2714\ufe0f Required Knowledge  "),(0,o.kt)("p",null,"\u274c Still requires some code in said language  "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Especially for UI")),(0,o.kt)("p",null,"So all in all we can share our code between platforms which improves development speed & quality in multiple ways."),(0,o.kt)("p",null,'The biggest "downside" is that even though we share the code we most likely will need some kind of specific code for the platform, for the GUI on iOS as an example. Perhaps ',(0,o.kt)("a",{parentName:"p",href:"https://www.jetbrains.com/lp/compose/"},"compose")," can help us get closer to that reality soon - who knows.",(0,o.kt)("br",{parentName:"p"}),"\n","The final, and perhaps obvious, one I'd like to mention straight away is that platform specific libraries of course are not usable on multiplatform. This includes libraries such as React (JS) & ",(0,o.kt)("inlineCode",{parentName:"p"},"ncurses")," (native)."),(0,o.kt)("p",null,"Personally I see Kotlin Multiplatform as a great way to ",(0,o.kt)("strong",{parentName:"p"},"share core logic")," between different targets, but one must use it with care and ",(0,o.kt)("strong",{parentName:"p"},"not try to force it")," into being used everywhere in every way."),(0,o.kt)("h1",{id:"part-2-how-to-set-up-multiplatform-and-build-snake"},"Part 2: How to set up Multiplatform and build Snake"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"OBS:"),' Make sure to have Kotlin 1.4 or higher before starting the project. You can verify version & update through File > Settings > Languages & Frameworks > Kotlin. There you see "current version" and if a newer one is available, make sure it\'s at least 1.4 (any higher will work too)!')),(0,o.kt)("p",null,"First we'll have to set up a Multiplatform project. The ",(0,o.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/mpp-create-lib.html"},"official guide")," is actually really good, and if you're using IntelliJ it's a breeze to setup! Just as in the guide make sure to select ",(0,o.kt)("inlineCode",{parentName:"p"},"Library"),".",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"OBS:"),' For each target (JVM, JS & Native) select "Template" and choose Application for each.'),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://kotlinlang.org/assets/images/reference/mpp/mpp-project-1.png",alt:"Select a project template"})),(0,o.kt)("p",null,"Run the build."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side-note:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"gradle")," is a really good build-tool that I'd like to discuss more. But for now let's just enjoy the simplicity of how our whole project 'automagically' just works and builds as expected while targeting different platforms.")),(0,o.kt)("h2",{id:"building-a-jvm-app-snake"},"Building a JVM App (Snake)"),(0,o.kt)("p",null,"Let's start simple, Keep It Simple Stupid (KISS) principle applied, and create a JVM app. JVM has multiple advantages while developing such as"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Easy to run on all OS:es"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("em",{parentName:"li"},"Great")," debugging!"),(0,o.kt)("li",{parentName:"ol"},"A ton of resources")),(0,o.kt)("p",null,"First off, we need to draw something. This is easiest done through the Swing library which is included in the default jdk, some might call it old but hey - it does the job.Create a file called ",(0,o.kt)("inlineCode",{parentName:"p"},"main.kt")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"src/jvmMain/kotlin"),"."),(0,o.kt)("p",null,"Swing has a built-in threading solution (almost too bad, because ",(0,o.kt)("inlineCode",{parentName:"p"},"Coroutines")," are awesome in Kotlin!) and the best way to start the GUI is by using the existing  ",(0,o.kt)("inlineCode",{parentName:"p"},"EventQueue")," class and its ",(0,o.kt)("inlineCode",{parentName:"p"},"invokeLater")," function. ",(0,o.kt)("inlineCode",{parentName:"p"},"invokeLater")," makes sure the code runs last in the ",(0,o.kt)("inlineCode",{parentName:"p"},"EventQueue")," if you add more methods, which makes sense - you want to draw the UI as the final thing."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun main() {\n    EventQueue.invokeLater {\n        JFrame().apply {\n            title = "Snake"\n            isVisible = true\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Where the ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," is a context wrapper that takes the object and uses it as context (",(0,o.kt)("inlineCode",{parentName:"p"},"this"),") inside of the block/scope (",(0,o.kt)("inlineCode",{parentName:"p"},"{}"),"). See its signature:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"inline fun <T> T.apply(block: T.() -> Unit): T")),(0,o.kt)("p",null,"This would equate to "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val jframe = JFrame()\njframe.title = "Snake"\njframe.isVisible = true\n')),(0,o.kt)("p",null,"in more Java-like syntax. Why use ",(0,o.kt)("inlineCode",{parentName:"p"},"apply"),"? It allows us to achieve some interesting chaining concepts which I really enjoy."),(0,o.kt)("p",null,"Now run the ",(0,o.kt)("inlineCode",{parentName:"p"},"main"),'-function, there should be a green "run"-button at the left, press that. Hopefully it compiles and a window will appear, with the title set to "Snake".'),(0,o.kt)("p",null,"Awesome! We need to render something inside of the box, a game soon enough, let's see how we can achieve that."),(0,o.kt)("p",null,"Adding some minor refactoring and some new classes we can draw something"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'class Board: JPanel() {\n    init {\n        TODO("""\n        - Set background to black\n        - Allow focus\n        - Set preferredSize to some 200x300\n        """)\n    }\n}\n\nclass GUI: JFrame() {\n    init {\n        title = "Snake"\n        isVisible = true\n        isResizable = false\n        setLocationRelativeTo(null)\n        defaultCloseOperation = EXIT_ON_CLOSE\n\n        TODO("Add the Board to the JFrame, through add()")\n    }\n}\n\nfun main() {\n    EventQueue.invokeLater {\n        GUI()\n    }\n}\n')),(0,o.kt)("p",null,"What are we doing?",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"JFrame")," was refactored ",(0,o.kt)("inlineCode",{parentName:"p"},"GUI")," which then is a subclass of ",(0,o.kt)("inlineCode",{parentName:"p"},"JFrame"),", with a few extra attributes added such as ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultCloseOperation = EXIT_ON_CLOSE")," that makes sure the program exits if we close the window, feel free to test it out!",(0,o.kt)("br",{parentName:"p"}),"\n","Further a ",(0,o.kt)("inlineCode",{parentName:"p"},"Board")," was added which extends ",(0,o.kt)("inlineCode",{parentName:"p"},"JPanel"),", it's in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Board")," the game will be rendered.",(0,o.kt)("br",{parentName:"p"}),"\n","Finally, ",(0,o.kt)("inlineCode",{parentName:"p"},"add(Board())")," allows us to add our ",(0,o.kt)("inlineCode",{parentName:"p"},"Board"),"  to the ",(0,o.kt)("inlineCode",{parentName:"p"},"JFrame"),"."),(0,o.kt)("p",null,"Run!",(0,o.kt)("br",{parentName:"p"}),"\n","Something is not right.. The background seems black enough, but the size is most likely not correct. We can't even resize as ",(0,o.kt)("inlineCode",{parentName:"p"},"isResizable=false")," was set.",(0,o.kt)("br",{parentName:"p"}),"\n","Make sure to add ",(0,o.kt)("inlineCode",{parentName:"p"},"pack()")," at the end, as in"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class GUI: JFrame() {\n    init {\n        { /** same code as before */ }\n        add(Board())\n        pack()\n    }\n}\n")),(0,o.kt)("p",null,"What ",(0,o.kt)("inlineCode",{parentName:"p"},"pack()")," does is that it packs and resizes the ",(0,o.kt)("inlineCode",{parentName:"p"},"JFrame")," to include all its component(s) and their current size(s)."),(0,o.kt)("p",null,"Super! We're now able to render our ",(0,o.kt)("inlineCode",{parentName:"p"},"Board")," and see the whole board."),(0,o.kt)("h3",{id:"drawing-the-snake--apple"},"Drawing the snake & apple"),(0,o.kt)("p",null,"We've got the canvas (Board), now we just need to get artsy and add a Snake and some Apples!",(0,o.kt)("br",{parentName:"p"}),"\n","I'll keep it simple and will make the Board exist of a few cells, all pretty large. On each cell you either have nothing, Snake or Apple - pretty simple right?",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"JPanel")," has some nice-to-have methods built-in, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"repaint()")," which simply repaints the component, which in turns calls ",(0,o.kt)("inlineCode",{parentName:"p"},"paintComponent(g: Graphics?)")," to paint/render it."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"Disclaimer:"),"  the code might not be the most idiomatic, but I try to introduce a few concepts.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class Board: JPanel() {\n    init { /** same code as before */ }\n\n    override fun paintComponent(g: Graphics?) {\n        super.paintComponent(g)\n        \n        val g2d: Graphics2D = g as? Graphics2D ?: return\n        \n        g2d.scale(20.0, 20.0)\n        g2d.color = Color.GREEN\n        g2d.fill(Rectangle(5, 6, 1, 1))\n        g2d.fill(Rectangle(5, 7, 1, 1))\n        g2d.fill(Rectangle(5, 8, 1, 1))\n    }\n}\n")),(0,o.kt)("p",null,"Once again, let's dive into what's happening 'under the hood'.  "),(0,o.kt)("p",null,"First, we override the function ",(0,o.kt)("inlineCode",{parentName:"p"},"paintComponent")," which renders ",(0,o.kt)("inlineCode",{parentName:"p"},"Board")," layout. The input is a ",(0,o.kt)("strong",{parentName:"p"},"nullable ",(0,o.kt)("inlineCode",{parentName:"strong"},"Graphics")),", which is shown by the type having a ",(0,o.kt)("inlineCode",{parentName:"p"},"?")," at the end. This is a cool property of Kotlin, if something can be ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," it actually is a type. No ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe"),", just pure type.  "),(0,o.kt)("p",null,"Then ",(0,o.kt)("inlineCode",{parentName:"p"},"Graphics?")," is cast to non-null ",(0,o.kt)("inlineCode",{parentName:"p"},"Graphics2D")," through a safe approach using ",(0,o.kt)("inlineCode",{parentName:"p"},"as?"),", without ",(0,o.kt)("inlineCode",{parentName:"p"},"?")," the cast can crash, with ",(0,o.kt)("inlineCode",{parentName:"p"},"?")," the cast would return ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if failing.  "),(0,o.kt)("p",null,"Finally we use a ",(0,o.kt)("strong",{parentName:"p"},"elvis-expression ",(0,o.kt)("inlineCode",{parentName:"strong"},"?:"))," which is basically a wrapper for ",(0,o.kt)("inlineCode",{parentName:"p"},"if (null) doThis else doThat"),", so if the left-hand-side is ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," it'll give the right-hand-side. The right-hand-side in our case is a empty ",(0,o.kt)("inlineCode",{parentName:"p"},"return")," statement, meaning that we just make a early-exit. If the value is ",(0,o.kt)("em",{parentName:"p"},"not")," ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," it'll give the non-null variant of the type! "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Example use-case of elvis-operator ",(0,o.kt)("inlineCode",{parentName:"p"},"?:"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"val a: Int = 1 ?: 0 // a = 1"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"val b: Int = null ?: 0 // b = 0")," ")),(0,o.kt)("p",null,"Detailing the code further we now have ",(0,o.kt)("inlineCode",{parentName:"p"},"g2d: Graphics2D")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"Graphics2D")," which gives us a few nice functions to draw components on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Board"),". "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We set the scale to 20",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"This simplifies the behaviour, we can now use 20x30 grid where each cell is size 1, but it's scaled into the 200x300 grid."))),(0,o.kt)("li",{parentName:"ul"},"We use ",(0,o.kt)("inlineCode",{parentName:"li"},"fill")," to draw ",(0,o.kt)("inlineCode",{parentName:"li"},"Rectangle"),"'s with set ",(0,o.kt)("inlineCode",{parentName:"li"},"Color"),".")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side-note:"),"\nFor those wondering how you safely execute on ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),"s by chaining, like you do with Monads (",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),")"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val nullableGraphics: Graphics? = null\nnullableGraphics?.scale(20.0, 20.0) // This is safe! No operation executed if null\n"))),(0,o.kt)("p",null,"Summing up, we now know how to render stuff on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Board")," and it's all very static.",(0,o.kt)("br",{parentName:"p"}),"\n","The next step is to make the rendering less static and I believe the natural step from now is to create the data structures that'll contain the game & its state. Then we can make sure the data structures are able to update, so we can render new states."),(0,o.kt)("h3",{id:"creating-the-data-structures"},"Creating the data structures"),(0,o.kt)("p",null,"Data structures are required to have a game state, that is the score and position of everything. "),(0,o.kt)("p",null,"The natural state is ",(0,o.kt)("inlineCode",{parentName:"p"},"Game")," which contains everything, let's begin by creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"Game")," structure which contains the size of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Board"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class Game(val width: Int, val height: Int)\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side-note:")," A ",(0,o.kt)("inlineCode",{parentName:"p"},"data class")," is essentially the same as a  ",(0,o.kt)("inlineCode",{parentName:"p"},"case class")," from Scala. And for those who don't know what a ",(0,o.kt)("inlineCode",{parentName:"p"},"case class")," is it's basically a ",(0,o.kt)("inlineCode",{parentName:"p"},"class")," that simplifies a lot of stuff, mainly used as a data structure.",(0,o.kt)("br",{parentName:"p"}),"\n","You get ",(0,o.kt)("inlineCode",{parentName:"p"},"equals"),", getters & setters, and much more for free.",(0,o.kt)("br",{parentName:"p"}),"\n","Anyone from Java knows how awesome this is.")),(0,o.kt)("p",null,"Moving on we need to define the cells mentioned, something like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class Cell(val x: Int, val y: Int)\n")),(0,o.kt)("p",null,"Wrapping up our current state we got most of what we need, ",(0,o.kt)("inlineCode",{parentName:"p"},"Game")," which contains our game state & ",(0,o.kt)("inlineCode",{parentName:"p"},"Cell")," which is our co-ordinates.",(0,o.kt)("br",{parentName:"p"}),"\n","The next step is to actually draw the ",(0,o.kt)("inlineCode",{parentName:"p"},"Cell"),"'s and wrap the ",(0,o.kt)("inlineCode",{parentName:"p"},"Cell")," in other classes such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Apple")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Snake"),".  "),(0,o.kt)("p",null,"Let's add all the required code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class Apples(val cells: Set<Cell> = emptySet())\n\ndata class Snake(val cells: List<Cell>) {\n    val head: Cell = TODO("Take the first cell.")\n    val tail: List<Cell> = TODO("Drop one cell and return the rest.")\n}\n\ndata class Game(\n    val width: Int,\n    val height: Int,\n    val snake: Snake,   // Adding snake and apples\n    val apples: Apples\n)\n\nclass Board: JPanel() {\n    private val game: Game = Game(\n        20,\n        30,\n        Snake(listOf(Cell(2,3),Cell(2,4),Cell(2,5),)),\n        Apples(setOf(Cell(4,5)))\n    )\n\n    init {\n        background = Color.black\n        isFocusable = true\n        preferredSize = Dimension(200, 300)\n    }\n\n    override fun paintComponent(g: Graphics?) {\n        super.paintComponent(g)\n        val g2d = g as? Graphics2D ?: return\n        g2d.scale(20.0, 20.0)\n\n        g2d.color = Color.GREEN\n        game.snake.tail.forEach { cell -> TODO("Render the cells using the previously used technique") }\n\n        TODO("Render the head using the color YELLOW")\n\n        TODO("Render the apples using the color RED")\n    }\n}\n')),(0,o.kt)("p",null,"Fixing the added ",(0,o.kt)("inlineCode",{parentName:"p"},"TODO"),"s and keeping the same ",(0,o.kt)("inlineCode",{parentName:"p"},"GUI")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"fun main")," we can now run the code. You should be seeing something like "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/97808473-5c427300-1c67-11eb-9fa9-9110f596533b.png",alt:"image"})),(0,o.kt)("p",null,"Pretty cool right!? We've got",(0,o.kt)("br",{parentName:"p"}),"\n","\u2714\ufe0f Rendering",(0,o.kt)("br",{parentName:"p"}),"\n","\u2714\ufe0f Data Structures"),(0,o.kt)("p",null,"What's left?"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A game loop"),(0,o.kt)("li",{parentName:"ol"},"Ability to actually move the data structures ( ",(0,o.kt)("inlineCode",{parentName:"li"},"Snake"),")")),(0,o.kt)("h4",{id:"adding-a-direction"},"Adding a Direction"),(0,o.kt)("p",null,"To be able to move we need to know what directions to move in. In my humble opinion this is simplest done through a ",(0,o.kt)("inlineCode",{parentName:"p"},"Enum"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"enum class Direction {\n    UP,\n    DOWN,\n    LEFT,\n    RIGHT\n}\n")),(0,o.kt)("p",null,"Simple enough. But let's make it better, even though pre-optimization is the root of all evil it is sometimes fun \ud83d\ude00.",(0,o.kt)("br",{parentName:"p"}),"\n","Enums in Kotlin are pretty awesome, they can both keep values and have methods! Let's add ",(0,o.kt)("inlineCode",{parentName:"p"},"dx")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"dy"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"enum class Direction(val dx: Int, val dy: Int) {\n    // --\x3e\n    // |\n    // v\n    UP(0, -1),\n    DOWN(0, 1),\n    LEFT(-1, 0),\n    RIGHT(1, 0);\n}\n")),(0,o.kt)("p",null,"Through ",(0,o.kt)("inlineCode",{parentName:"p"},"dx")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"dy")," we can add it to the current cell to move in the direction which ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction")," is!"),(0,o.kt)("p",null,"Updating ",(0,o.kt)("inlineCode",{parentName:"p"},"Snake.kt")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"Cell.kt")," to have ",(0,o.kt)("inlineCode",{parentName:"p"},"Cell")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction")," and some ",(0,o.kt)("inlineCode",{parentName:"p"},"turn"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class Cell(val x: Int, val y: Int) {\n    fun move(direction: Direction) = TODO("Create new cell which moves in direction. OBS: Remember Direction now has dx, dy!")\n}\n\ndata class Snake(\n    val cells: List<Cell>,\n    val direction: Direction, // new attribute\n    val eatenApples: Int = 0 // new attribute\n) {\n    fun move(): Snake {\n        val newHead = TODO("Move head")\n        val newTail = TODO("Move tail!")\n        return TODO("Create a new Snake with the updated position!")\n    }\n    fun turn(newDirection: Direction?) = TODO("Make sure to turn correctly")\n}\n')),(0,o.kt)("p",null,"This is all fine & dandy, but there is some improvements to be made that'll clean up the code.",(0,o.kt)("br",{parentName:"p"}),"\n","I mentioned that Kotlin ",(0,o.kt)("inlineCode",{parentName:"p"},"Enums")," can have methods, which is awesome. We can simplify the ",(0,o.kt)("inlineCode",{parentName:"p"},"turn"),"-logic by adding a method to ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction"),", namely ",(0,o.kt)("inlineCode",{parentName:"p"},"isOppositeTo"),". See the code below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"enum class Direction(val dx: Int, val dy: Int) {\n    /** Same code as previously */\n\n    fun isOppositeTo(that: Direction) =\n        dx + that.dx == 0 && dy + that.dy == 0\n}\n")),(0,o.kt)("p",null,"Right, we can now turn the snake and render the game. We need the ",(0,o.kt)("inlineCode",{parentName:"p"},"Game"),"-state to update to actually re-render the updated Snake, let's add a ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),"-function that does this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun update(direction: Direction?): Game {\n    return TODO("""\n    Make sure to\n        1. Turn snake in direction\n        2. Move\n        3. Update the game state by returning Game\n    """)\n}\n')),(0,o.kt)("p",null,"And our GUI"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'class Board: JPanel() {\n    var dir: Direction = Direction.RIGHT\n    var game: Game = Game(\n        20,\n        30,\n        Snake(listOf(Cell(2,3),Cell(2,4),Cell(2,5),), dir),\n        Apples(setOf(Cell(4,5)))\n    )\n    \n    init {\n        addKeyListener(object : KeyAdapter() {\n            override fun keyPressed(e: KeyEvent?) {\n                dir = when (e?.keyCode) {\n                    VK_I, VK_UP, VK_W -> Direction.UP\n                    else -> TODO("Add the other key bindings. Reflect of how the object works and what is happening.")\n                }\n                game = game.update(dir)\n                repaint()\n            }\n        })\n    }\n}\n')),(0,o.kt)("p",null,"In our ",(0,o.kt)("inlineCode",{parentName:"p"},"init")," (equal to a constructor) we add a ",(0,o.kt)("inlineCode",{parentName:"p"},"keyListener")," which will listen on whenever we move. We moved ",(0,o.kt)("inlineCode",{parentName:"p"},"game")," to be a ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," which allows us to change the reference."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side-note:")," The difference between a ",(0,o.kt)("inlineCode",{parentName:"p"},"val")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," is not about immutability of the value, but rather that you cannot change the pointer to the object. By using ",(0,o.kt)("inlineCode",{parentName:"p"},"val")," the compiler don't allow you to change the reference.  "),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val a = 1\na = 3 // CRASH -- This is not allowed\nvar b = 1\nb = 3 // b = 3, this is allowed.\n")),(0,o.kt)("p",{parentName:"blockquote"},"Please note that this means that if your object is mutable, you can mutate the state of the object even though it's a ",(0,o.kt)("inlineCode",{parentName:"p"},"val"),".")),(0,o.kt)("p",null,"Why put ",(0,o.kt)("inlineCode",{parentName:"p"},"game")," on a ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," you might ask? Otherwise how would we update our ",(0,o.kt)("inlineCode",{parentName:"p"},"Game"),' as the data structure itself is "immutable", i.e. cannot be changed, which would mean that we\'d need to add a new ',(0,o.kt)("inlineCode",{parentName:"p"},"Game")," object each time and save it on the stack (never cleaning it up) and that'd pretty fast make the application crash because of ",(0,o.kt)("inlineCode",{parentName:"p"},"out of memory"),"."),(0,o.kt)("p",null,"Finally, we update the game by calling our created ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),"-method and then we use ",(0,o.kt)("inlineCode",{parentName:"p"},"repaint()")," which draws the components!"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Remember:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"paintComponent")," draws the canvas (game), so whenever ",(0,o.kt)("inlineCode",{parentName:"p"},"repaint")," is called ",(0,o.kt)("inlineCode",{parentName:"p"},"paintComponent")," draws the game again based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"game")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"cell"),"'s in the game.")),(0,o.kt)("p",null,"In conclusion this gives us an incredibly simple game, the snake moves whenever we press a key as we ",(0,o.kt)("em",{parentName:"p"},"still don't have a game loop")," based on time. So how do we add a game loop based on time?"),(0,o.kt)("p",null,"The JVM got you covered! In the ",(0,o.kt)("inlineCode",{parentName:"p"},"keyListener")," remove the update & repaint, then add a ",(0,o.kt)("inlineCode",{parentName:"p"},"timer ")," "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'fixedRateTimer(TODO("Explore options to use for the timer and how they work")) {\n    TODO("Insert a game loop here, essentially the same as done in the keyListener previously!")\n}\n')),(0,o.kt)("p",null,"Run the game! ...amazing right?  "),(0,o.kt)("p",null,"We now move our snake, and it moves by itself if we don't.\nBut the game is still pretty boring... We never die, no apples can be eaten and finally no new apples appear. We have a few additions to make to make the game a bit challenging.."),(0,o.kt)("p",null,"Let's start by fixing the apples. Update the ",(0,o.kt)("inlineCode",{parentName:"p"},"Apples.kt")," to randomly add apples to the board when calling ",(0,o.kt)("inlineCode",{parentName:"p"},"grow()"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"To simplify the logic we use a ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," which means that all apples added are unique.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class Apples(\n    val width: Int,\n    val height: Int,\n    val cells: Set<Cell> = emptySet(),\n    val growthSpeed: Int = 3, // this could actually be to only spawn apple when there is no other apple. Up to user\n    val random: Random = Random // Once again, Kotlin provides a superb class, in this case a Random wrapper that works on JVM, JS & Native - cool right?\n) {\n    fun grow(): Apples {\n        return TODO("""\n        If we have a random number greater than growthSpeed, return no update. \n        Otherwise add a new cell.\n        """)\n    }\n}\n')),(0,o.kt)("p",null,"Then we should allow the Snake to eat them, make sure to add ",(0,o.kt)("inlineCode",{parentName:"p"},"eat(apples: Apples)")," method and implement it for ",(0,o.kt)("inlineCode",{parentName:"p"},"Snake.kt"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun eat(apples: Apples): Pair<Snake, Apples> {\n    return TODO("""\n    If our head is on a Apple location, return a pair of Snake and Apple untouched.\n    Otherwise make sure to remove the apple from apples and increase body size of snake!\n    """)\n}\n')),(0,o.kt)("p",null,"At the end of all this we need the ",(0,o.kt)("inlineCode",{parentName:"p"},"Game.kt")," to allow this logic to be used. This is done through updating ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," to allow the snake to ",(0,o.kt)("inlineCode",{parentName:"p"},"eat")," apples and also ",(0,o.kt)("inlineCode",{parentName:"p"},"grow")," apples to add new ones."),(0,o.kt)("p",null,"Great! We can eat apples, add new apples and all. But we're still pretty invincible and we'll just keep going forever.\nWe need to make sure that the end can be lost, let's do it by adding a new attribute ",(0,o.kt)("inlineCode",{parentName:"p"},"isOver")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Game.kt")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val score: Int = TODO("Score based on snakes size, e.g. cell size")\nval isOver: Boolean = TODO("Game is over if snake head in tail or snake head not on the map!")\n\nfun update(dir: Direction): Game {\n    if (isOver) return this\n    { /** same code as was here before */ }\n}\n')),(0,o.kt)("h2",{id:"wrapping-up-the-code-with-some-minor-refactoring--new-functionality"},"Wrapping up the code with some minor refactoring / new functionality"),(0,o.kt)("p",null,"Kotlin has a wonderful concept of ",(0,o.kt)("strong",{parentName:"p"},"extension functions"),", which simply is incredible. An extension function extends a class with new functionality. Did you ever wish ",(0,o.kt)("inlineCode",{parentName:"p"},"Double")," had a rounding to string? ",(0,o.kt)("inlineCode",{parentName:"p"},'fun Double.roundTo(n: Int): String = "%.${decimals}f".format(this)')," solves this for you! Now your ",(0,o.kt)("inlineCode",{parentName:"p"},"Double"),"'s automatically gives you a hint to use ",(0,o.kt)("inlineCode",{parentName:"p"},".roundTo")," as one of ",(0,o.kt)("inlineCode",{parentName:"p"},"Double"),"'s built-in functions!"),(0,o.kt)("p",null,"With these we can update our main-method to be a tiny bit cleaner."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"g2d.color = Color.GREEN\ngame.snake.tail.forEach { cell -> g2d.fill(Rectangle(cell.x, cell.y, 1, 1)) }\n\n// Turns into --\x3e\n\nfun Graphics2D.renderCells(color: Color, cells: Iterable<Cell>) {\n    this.color = color\n    cells.forEach { cell -> fill(Rectangle(cell.x, cell.y, 1, 1)) }\n}\n\n/**\n    Which allows us to just call `g2d.renderCells(Color.GREEN, game.snake.tail)` etc.\n*/\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"What more improvements can be made?")),(0,o.kt)("p",null,"Exercises left for the reader:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Add Score on the loosing screen"),(0,o.kt)("li",{parentName:"ol"},"Add a win-condition (basically impossible, but taking all apples)"),(0,o.kt)("li",{parentName:"ol"},"Reinforcement learning to train a bot (might be a future blog!)"),(0,o.kt)("li",{parentName:"ol"},"Better & cleaner code!")),(0,o.kt)("h1",{id:"part-3-true-multiplatform-moving-to-js--native"},"Part 3: True multiplatform (moving to JS & Native)"),(0,o.kt)("p",null,"I'll begin by saying that this part is more of a reader exercise. If you want the finished code please go to the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/londogard/snake-js-jvm-native/tree/completed_project"},"GitHub repository"),".",(0,o.kt)("br",{parentName:"p"}),"\n","The idea is that this part will be solved by yourself during the workshop this is intended for."),(0,o.kt)("p",null,"All the snake-related code that isn't in your ",(0,o.kt)("inlineCode",{parentName:"p"},"main.kt"),"-file should be moved into ",(0,o.kt)("inlineCode",{parentName:"p"},"src/commonMain/kotlin")," which makes it ",(0,o.kt)("strong",{parentName:"p"},"multiplatform"),"-code. This means that it can target JS, Native & JVM instantly! "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side-note:")," because all the functionality for the Data Structures (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"take"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Random"),") exists in Kotlin std-lib it's automatically possible to use in multiplatform.")),(0,o.kt)("p",null,"This is not true all the time, if we use platform-specific code. Our platform-specific code, tied with the JVM, is the ",(0,o.kt)("inlineCode",{parentName:"p"},"timer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Swing")," which means that our whole GUI is tied to the JVM. "),(0,o.kt)("p",null,"When the code has been migrated and import-paths are updated, run the JVM app again and validate that everything works."),(0,o.kt)("h2",{id:"jsbrowser-target"},"JS/Browser target"),(0,o.kt)("p",null,"Now create ",(0,o.kt)("inlineCode",{parentName:"p"},"src/jsMain/kotlin/main.kt"),"."),(0,o.kt)("p",null,"In this file we need to define how to draw the browser-based GUI. Some key methods, for the full code check out the git repository."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"KeyListener"),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"document.onkeydown = { event -> onkeydown(event).also { keyDir -> dir = keyDir } }")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"onkeydown")," is your own method that handles key-events."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Timer"),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"window.setInterval({ game = game.update(dir); render(canvas, game) }, 200)")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Canvas"),"  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val canvas = document.getElementById("snake-canvas") as HTMLCanvasElement\nval ctx = canvas.getContext("2d") as CanvasRenderingContext2D\n')),(0,o.kt)("p",null,"On this ",(0,o.kt)("inlineCode",{parentName:"p"},"ctx")," from the canvas you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"fillRect")," to draw rectangles, and ",(0,o.kt)("inlineCode",{parentName:"p"},"fillStyle")," to set color."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"HTML-Canvas"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},'<canvas id="snake-canvas" width="400px" height="300px"></canvas>')," (put in ",(0,o.kt)("inlineCode",{parentName:"p"},"index.html"),")"),(0,o.kt)("p",null,"The game is run through ",(0,o.kt)("inlineCode",{parentName:"p"},"./gradlew jsBrowserRun"),", or selecting the gradle-icon at the top right (elephant) and typing ",(0,o.kt)("inlineCode",{parentName:"p"},"jsBrowserRun"),"."),(0,o.kt)("p",null,"And the code for the GUI using these components is pretty much exactly the same as in Swing to be honest. "),(0,o.kt)("p",null,"Congratulations, you have now achieved creating a desktop game and a browser game!"),(0,o.kt)("h2",{id:"native-target"},"Native target"),(0,o.kt)("p",null,"And onto our final target, Native Binary, that runs completely without a browser or a virtual machine."),(0,o.kt)("p",null,"For the Native target the GUI will be supported through the library ",(0,o.kt)("inlineCode",{parentName:"p"},"ncurses")," which unfortunately is only supported on Linux & MacOS. If you've windows you can solve this through ",(0,o.kt)("em",{parentName:"p"},"Windows Subsystem for Linux")," (WSL)."),(0,o.kt)("p",null,"Begin by creating ",(0,o.kt)("inlineCode",{parentName:"p"},"src/nativeMain/kotlin/main.kt"),"."),(0,o.kt)("p",null,"To begin, in the main-function do the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun maint(): Unit = memScoped {\n    // insert code\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"memScoped")," part means that all memory allocated in the block is automatically disposed at the end, incredibly useful! :happy:"),(0,o.kt)("p",null,"Then reading how to use ",(0,o.kt)("inlineCode",{parentName:"p"},"ncurses")," we can figure out how to init this. The final end-goal being"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun main(): Unit = memScoped {\n    initscr()\n\n    defer { endwin() }\n    noecho()\n    curs_set(0)\n    halfdelay(2)\n\n    var game: Game = TODO()\n    val window = newwin(game.height + 2, game.width + 2, 0, 0)!!\n    defer { delwin(window) }\n\n    var input = 0\n    while (input.toChar() != \'q\') {\n        window.draw(game)\n\n        input = wgetch(window)\n        val direction = when (input.toChar()) {\n            \'i\' -> TODO("")\n        }\n        game = game.update(direction)\n    }\n}\n\nprivate fun CPointer<WINDOW>.draw(game: Game) {\n    wclear(this)\n    box(this, 0u, 0u)\n\n    game.apples.cells.forEach { mvwprintw(this, it.y + 1, it.x + 1, ".") }\n    game.snake.tail.forEach { mvwprintw(this, it.y + 1, it.x + 1, "o") }\n    game.snake.head.let { mvwprintw(this, it.y + 1, it.x + 1, "Q") }\n\n    if (game.isOver) {\n        mvwprintw(this, 0, 6, "Game Over")\n        mvwprintw(this, 1, 3, "Your score is ${game.score}")\n    }\n\n    wrefresh(this)\n}\n')),(0,o.kt)("p",null,"Try running it in the terminal."),(0,o.kt)("p",null,"This blog was created as a companion to a workshop I'm gonna do at AFRY, it has a bit more content including a presentation in person."),(0,o.kt)("p",null,"All the finished code is available ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/londogard/snake-js-jvm-native/tree/completed_project"},"here"),", if you prefer the unfinished code head to ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/londogard/snake-js-jvm-native"},"master-branch"),"."),(0,o.kt)("p",null,"Thanks!"),(0,o.kt)("p",null,"~Hampus"))}u.isMDXComponent=!0}}]);