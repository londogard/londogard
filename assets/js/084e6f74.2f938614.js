"use strict";(self.webpackChunklondogard=self.webpackChunklondogard||[]).push([[8150],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(a),h=r,c=u["".concat(s,".").concat(h)]||u[h]||m[h]||i;return a?n.createElement(c,o(o({ref:t},p),{},{components:a})):n.createElement(c,o({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},895:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},assets:function(){return p},toc:function(){return m},default:function(){return h}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],l={description:"Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance & a much more efficient model.",tags:["nlp","machine-learning","workshop"],title:"Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface)",authors:"hlondogard"},s=void 0,d={permalink:"/blog/2021/03/29/swedish-named-entity-recognition",editUrl:"https://github.com/londogard/londogard/blog/2021-03-29-swedish-named-entity-recognition.md",source:"@site/blog/2021-03-29-swedish-named-entity-recognition.md",title:"Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface)",description:"Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance & a much more efficient model.",date:"2021-03-29T00:00:00.000Z",formattedDate:"March 29, 2021",tags:[{label:"nlp",permalink:"/blog/tags/nlp"},{label:"machine-learning",permalink:"/blog/tags/machine-learning"},{label:"workshop",permalink:"/blog/tags/workshop"}],readingTime:10.68,truncated:!0,authors:[{name:"Hampus Lond\xf6g\xe5rd",title:"Main Contributor of Londogard",url:"https://github.com/lundez",imageURL:"https://github.com/lundez.png",key:"hlondogard"}],frontMatter:{description:"Learn how to fine-tune a Flair NER model and quantize a BERT model from Huggingface to achieve SotA performance & a much more efficient model.",tags:["nlp","machine-learning","workshop"],title:"Building a Swedish Named Entity Recognition (NER) model (Flair/Huggingface)",authors:"hlondogard"},prevItem:{title:"TIL: GitHub Pages + Progressive Web App (PWA) = \u2764\ufe0f",permalink:"/blog/2021/04/11/til-pwa-github-pages"},nextItem:{title:"When to use what - RegExp, String Replace & Character Replace (JVM/Kotlin)",permalink:"/blog/2021/03/17/replace-in-string"}},p={authorsImageUrls:[void 0]},m=[{value:"Named Entity Recognition and how it can do your bidding",id:"named-entity-recognition-and-how-it-can-do-your-bidding",children:[],level:2},{value:"Flair(ing) the way to success",id:"flairing-the-way-to-success",children:[],level:2},{value:"Swedish data",id:"swedish-data",children:[],level:2},{value:"Training the flair",id:"training-the-flair",children:[{value:"Setting up the Corpus / Dataset",id:"setting-up-the-corpus--dataset",children:[],level:3},{value:"Model Setup",id:"model-setup",children:[],level:3},{value:"Training the model",id:"training-the-model",children:[],level:3}],level:2},{value:"Result",id:"result",children:[],level:2},{value:"Deploying on streamlit.io/sharing",id:"deploying-on-streamlitiosharing",children:[],level:2},{value:"Outro",id:"outro",children:[],level:2}],u={toc:m};function h(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Not interested in reading the whole article and just wanna play around with the model(s)? Head over to ",(0,i.kt)("a",{parentName:"p",href:"https://londogard.com/ner"},"londogard.com/ner"),".\n",(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7490199/113611097-543f9280-964e-11eb-9e59-bd030c32ad0c.png",alt:"image"}),"\n",(0,i.kt)("strong",{parentName:"p"},"P.S.")," The Flair model is available for simple installation through ",(0,i.kt)("a",{parentName:"p",href:"https://huggingface.co/londogard/flair-swe-ner"},"huggingface.co's model hub")),(0,i.kt)("h1",{id:"building-a-swedish-named-entity-recognition-ner-model"},"Building a Swedish Named Entity Recognition (NER) model"),(0,i.kt)("p",null,"At ",(0,i.kt)("em",{parentName:"p"},"Londogard")," we aim to employ Natural Language Processing (NLP) in a practical manner. The goal is not to create the models of OpenAI or Google, but rather something that is usable from the get-go and performant leading to a simple to use product.",(0,i.kt)("br",{parentName:"p"}),"\n","In this post I'll cover how we at Londogard developed a State-of-the-Art (SotA) Named Entity Recognition (NER) model for Swedish using Flair & huggingface. \ud83c\udf89"),(0,i.kt)("p",null,"It all started last weekend when I was allowed into the ",(0,i.kt)("a",{parentName:"p",href:"https://streamlit.io/"},"streamlit.io"),"'s ",(0,i.kt)("em",{parentName:"p"},"sharing")," beta.",(0,i.kt)("br",{parentName:"p"}),"\n","If you don't know what streamlit, here's an excerpt from their frontpage:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"The fastest way to build and share data apps"),"\nStreamlit turns data scripts into shareable web apps in minutes.",(0,i.kt)("br",{parentName:"p"}),"\n","All in Python. All for free. No front\u2011end experience required.")),(0,i.kt)("p",null,"Essentially streamlit is a way to combine backend & frontend into a unified script-like experience where the default UI looks pretty good. On top of this script-like experience streamlit has built a powerful yet simple to use cache system."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In my opinion creating demos has never been simpler than with streamlit.io")),(0,i.kt)("p",null,"Back to the problem at hands, I wished to deploy a model through streamlit that actually was a meaningful experience where efficiency and performance are combined, according to the Londogard motto.",(0,i.kt)("br",{parentName:"p"}),"\n","As such I embarked on the journey that was to deploy a NER model for ",(0,i.kt)("em",{parentName:"p"},"Swedish")," where Swedish actually isn't all to common in NLP. Lately ",(0,i.kt)("em",{parentName:"p"},"Kungliga Biblioteket")," has been trying to improve this through their ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Kungbib/swedish-spacy"},"spaCy-contribution"),", which yet has to be included in spaCy, and their ",(0,i.kt)("a",{parentName:"p",href:"https://huggingface.co/KB/"},"HuggingFace-contributions")," where we can find BERT, Electra & Albert pre-trained.",(0,i.kt)("br",{parentName:"p"}),"\n","My first idea was to take one of these and fine-tune to finally deploy, but the size of BERT is too large as is. "),(0,i.kt)("p",null,"What choices are left to allow deploy of these models?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Distilling \u2697\ufe0f"),(0,i.kt)("li",{parentName:"ul"},"Quantizing"),(0,i.kt)("li",{parentName:"ul"},"Fine-tuning ALBERT on NER",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Performance has been shown to be quite a bit below BERT (7% units) in a paper by KTH, for Swedish.")))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"So what did I do?")," I did as any other professional and google'd.",(0,i.kt)("br",{parentName:"p"}),"\n","A library I hadn't heard the name of in a year popped up at the top of the results, I was intrigued.",(0,i.kt)("br",{parentName:"p"}),"\n","Flair, a library that was created by Zalando Research, now under the flag ",(0,i.kt)("inlineCode",{parentName:"p"},"/flairnlp")," which in practice means that the core contributor-group has been changed to Humbold-University of Berlin.",(0,i.kt)("br",{parentName:"p"}),"\n","Flair contains the so-called ",(0,i.kt)("em",{parentName:"p"},"Flair Embeddings")," which are contextual embeddings of high quality. Flair retains SotA for NER in multiple languages through these and the performance is pretty damn good over all."),(0,i.kt)("p",null,"Before I dive into the details on how I trained my own model you can find a demo on ",(0,i.kt)("a",{parentName:"p",href:"https://londogard.com/ner"},"londogard.com/ner"),", where the model is deployed through ",(0,i.kt)("a",{parentName:"p",href:"https://streamlit.io/"},"streamlit.io"),"."),(0,i.kt)("h2",{id:"named-entity-recognition-and-how-it-can-do-your-bidding"},"Named Entity Recognition and how it can do your bidding"),(0,i.kt)("p",null,"As the name suggests NER is the task to recognize entities in text. Entities can be a lot of different things such as the obvious ",(0,i.kt)("em",{parentName:"p"},"Person")," but also ",(0,i.kt)("em",{parentName:"p"},"Location"),", ",(0,i.kt)("em",{parentName:"p"},"Organisation")," & ",(0,i.kt)("em",{parentName:"p"},"Time"),". More entities exists and they can really become whatever your data allows (",(0,i.kt)("em",{parentName:"p"},"Brand"),", ",(0,i.kt)("em",{parentName:"p"},"Medicine")," or ",(0,i.kt)("em",{parentName:"p"},"Dosage"),"? You got it!)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Practical use-cases of NER")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Automatic anonymization of data"),(0,i.kt)("li",{parentName:"ol"},"Medical prescription"),(0,i.kt)("li",{parentName:"ol"},"Automatically tag data",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g. News tagged by Organisations, Persons & Locations included")))),(0,i.kt)("p",null,"... & much more"),(0,i.kt)("p",null,"In my case I'm simply aiming for the traditional NER model which categorize things like ",(0,i.kt)("em",{parentName:"p"},"Location"),", ",(0,i.kt)("em",{parentName:"p"},"Person")," & ",(0,i.kt)("em",{parentName:"p"},"Organisation"),"."),(0,i.kt)("h2",{id:"flairing-the-way-to-success"},"Flair(ing) the way to success"),(0,i.kt)("p",null,"Flair is a SotA NLP library developed by ",(0,i.kt)("a",{parentName:"p",href:"https://www.informatik.hu-berlin.de/en/forschung-en/gebiete/ml-en/"},"Humboldt University of Berlin")," and friends. As mentioned its core contributors are from Humboldt University of Berlin and the whole idea is to provide contextual embeddings. Some of the things provided through Flair:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Flair Embeddings"),(0,i.kt)("li",{parentName:"ol"},"(Easily) Stacked Embeddings",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g. combine Transformer, Flair & GloVe for your end-model"))),(0,i.kt)("li",{parentName:"ol"},"Easy access to multiple embeddings",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"GloVe, Transformer, ELMo & many more"))),(0,i.kt)("li",{parentName:"ol"},"Simple training of high-performant NER (Token Classifier) Model and a Text Classifier model")),(0,i.kt)("p",null,"As mentioned Flair retain SotA in multiple languages for NER, but they do the same for POS.  "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The Language Model"),(0,i.kt)("br",{parentName:"p"}),"\n","If you're curious the simplest Flair embeddings are essentially a Language Model built on Dropout, LSTM & a Linear Layer. Pretty simple."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The Token Classifier (NER/POS)"),(0,i.kt)("br",{parentName:"p"}),"\n","It's based on a small LSTM-network with a CRF on top. The LSTM exists to create features for the CRF to learn and tag from. This is a very common approach which yields high accuracy. If you're aware of what features you wish to use a pure CRF can be very strong, Stanford NLP library was actually for very long based on a CRF and had SotA, but the manual feature engineering can be expensive & hard."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The Text Classifier"),"\nSimply a linear layer on top of the embeddings."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"More Models"),(0,i.kt)("br",{parentName:"p"}),"\n","Flair actually supports two other tasks, ",(0,i.kt)("em",{parentName:"p"},"Text Regression")," & ",(0,i.kt)("em",{parentName:"p"},"Similarity")," but I won't go in to those."),(0,i.kt)("p",null,"More about how I trained my NER will come a bit further down.\nTo read more about Flair and how they work please check out their ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flairNLP/flair"},"GitHub")," which also links to the papers."),(0,i.kt)("h2",{id:"swedish-data"},"Swedish data"),(0,i.kt)("p",null,"First of all I had to go find some data and I found cr\xe8me de la cr\xe8me in ",(0,i.kt)("a",{parentName:"p",href:"https://spraakbanken.gu.se/en/resources/suc3"},"SUC 3.0"),", because we really do sentence by sentence training in NER it's not the end of the world that the 'free' variant that doesn't require a research licence is scrambled. Unscrambled data would lead to a better model but it's still doable."),(0,i.kt)("p",null,"But as Jeremy Howard proposes, start with small and simple data then expand into your full task. SUC 3.0 is pretty large and slow to train. With some fast googling I found a saviour, ",(0,i.kt)("em",{parentName:"p"},"klintan"),". Klintan has created a open Swedish NER dataset based on Webbnyheter 2020 from Spr\xe5kbanken, it's semi-manually annotated. This means that he first based it on ",(0,i.kt)("em",{parentName:"p"},"Gazetters"),", essentially dataset(s) of entities, and then manually reviewed the data with two different native Swedish Speakers. More people have later added some improvements on top of that, find the full dataset ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/klintan/swedish-ner-corpus"},"here"),", but please note that ",(0,i.kt)("em",{parentName:"p"},"it's much smaller")," than SUC 3.0.",(0,i.kt)("br",{parentName:"p"}),"\n","After finding this dataset I read more into Flair and I found out that they actually provide this dataset through their API and in this dataset we have 4 categories PER, ORG, LOC and MISC."),(0,i.kt)("p",null,"With these two datasets in mind I went ahead to train."),(0,i.kt)("h2",{id:"training-the-flair"},"Training the flair"),(0,i.kt)("p",null,"First let me say the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flairNLP/flair/tree/master/resources/docs"},"documentation")," is actually pretty good!\nFirst part is to set up the ",(0,i.kt)("inlineCode",{parentName:"p"},"Corpus"),"."),(0,i.kt)("h3",{id:"setting-up-the-corpus--dataset"},"Setting up the Corpus / Dataset"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The built-in ",(0,i.kt)("em",{parentName:"strong"},"klintan/ner-swedish-corpus"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# 1. get the corpus\ncorpus: Corpus = NER_SWEDISH()\nprint(corpus)\n\n# 2. what tag do we want to predict?\ntag_type = 'ner'\n\n# 3. make the tag dictionary from the corpus\ntag_dictionary = corpus.make_tag_dictionary(tag_type=tag_type)\nprint(tag_dictionary)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Custom dataset (SUC 3.0, in my case scrambled)"),(0,i.kt)("br",{parentName:"p"}),"\n","Remember to convert the SUC tags into a IOB format before training. Emil Stenstr\xf6m has kindly created a simple Python-script for this available through ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/EmilStenstrom/suc_to_iob"},"github.com/EmilStenstrom/suc_to_iob"),". First transform the data and later you can run the following code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"columns = {0: 'text', 1: 'ner'}\n\n# this is the folder in which train, test and dev files reside\ndata_folder = 'path/to/data/suc'\n\n# init a corpus using column format, data folder and the names of the train, dev and test files\ncorpus: Corpus = ColumnCorpus(data_folder, columns, train_file='train.txt', test_file='test.txt', dev_file='dev.txt')\n\n# 2. what tag do we want to predict?\ntag_type = 'ner'\n\n# 3. make the tag dictionary from the corpus\ntag_dictionary = corpus.make_tag_dictionary(tag_type=tag_type)\nprint(tag_dictionary)\n")),(0,i.kt)("p",null,"With this in mind we're ready to set up our model for training."),(0,i.kt)("h3",{id:"model-setup"},"Model Setup"),(0,i.kt)("p",null,"Our model will build on ",(0,i.kt)("inlineCode",{parentName:"p"},"FlairEmbeddings")," (e.g. contextual embeddings) and ",(0,i.kt)("inlineCode",{parentName:"p"},"BytePairEmbeddings")," which are a bit like classic ",(0,i.kt)("inlineCode",{parentName:"p"},"WordEmbeddings")," but done on BPE-tokenized text. This is a really interesting approach which achieves similar performance as ",(0,i.kt)("inlineCode",{parentName:"p"},"fastText")," using ~ 0.2 % of the total size (11mb vs 6gb).",(0,i.kt)("br",{parentName:"p"}),"\n","The model itself will use a LSTM with a hidden size of 256 and a CRF classifier on top."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# 4. initialize embeddings\nembedding_types = [\n    # WordEmbeddings('sv'), # uncomment to add WordEmb\n    BytePairEmbeddings('sv'),\n    FlairEmbeddings(\"sv-forward\"),\n    FlairEmbeddings(\"sv-backward\")\n]\n\nembeddings: StackedEmbeddings = StackedEmbeddings(embeddings=embedding_types)\n\n# 5. initialize sequence tagger\ntagger: SequenceTagger = SequenceTagger(hidden_size=256,\n                                        embeddings=embeddings,\n                                        tag_dictionary=tag_dictionary,\n                                        tag_type=tag_type,\n                                        use_crf=True)\n")),(0,i.kt)("h3",{id:"training-the-model"},"Training the model"),(0,i.kt)("p",null,"Because I run through google colab and the machine can be terminated any second I run using ",(0,i.kt)("inlineCode",{parentName:"p"},"checkpoint=True")," which means you can continue training where you left off. My models are saved to my Google Drive, real handy! "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Pro-tip: use ",(0,i.kt)("inlineCode",{parentName:"p"},"checkpoint=True")," in combination with Google Drive on your Google Colab."),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# 7. start training\ntrainer.train('drive/MyDrive/path/to/model/save/',\n                learning_rate=0.1,\n                # set chunk size to lower memory requirements\n                #mini_batch_chunk_size=16,\n                mini_batch_size=32,\n                checkpoint=True,\n                embeddings_storage_mode='none', # only required for SUC 3.0 which grows too large\n                #batch_growth_annealing=True,\n                #anneal_with_restarts=True,\n                max_epochs=150)\n")),(0,i.kt)("h3",{parentName:"blockquote",id:"loading-model-from-checkpoint"},"Loading model from checkpoint"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-python"},"trainer = ModelTrainer.load_checkpoint('drive/MyDrive/path/to/model/save/checkpoint.pt', corpus)\n")),(0,i.kt)("p",{parentName:"blockquote"},"And that's it!")),(0,i.kt)("h2",{id:"result"},"Result"),(0,i.kt)("p",null,"For me the results looks really good and close to what I expected, I had hoped that Flair would achieve at least 0.88+ F1 but 0.855 isn't too bad. The size, speed and simplicity of Flair makes it a great contender!"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Dataset"),(0,i.kt)("th",{parentName:"tr",align:null},"Size"),(0,i.kt)("th",{parentName:"tr",align:null},"Avg F1"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"klintan/swedish-ner-corpus"),(0,i.kt)("td",{parentName:"tr",align:null},"320MB"),(0,i.kt)("td",{parentName:"tr",align:null},"~",(0,i.kt)("strong",{parentName:"td"},"0.89"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SUC 3.0 (PER, LOC & ORG)"),(0,i.kt)("td",{parentName:"tr",align:null},"320MB"),(0,i.kt)("td",{parentName:"tr",align:null},"~",(0,i.kt)("strong",{parentName:"td"},"0.89"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SUC 3.0 (PER, LOC, ORG, TME, MSR, ...)"),(0,i.kt)("td",{parentName:"tr",align:null},"320MB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0.855"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SUC 3.0 (PER, LOC, ORG, TME, MSR, ...) Quantized"),(0,i.kt)("td",{parentName:"tr",align:null},"80MB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0.853"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SUC 3.0 (PER, LOC, ORG, TME, MSR, ...) w/ ALBERT"),(0,i.kt)("td",{parentName:"tr",align:null},"50MB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0.85")," (via ",(0,i.kt)("a",{parentName:"td",href:"http://kth.diva-portal.org/smash/get/diva2:1451804/FULLTEXT01.pdf"},"KTH"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SUC 3.0 (PER, LOC, ORG, TME, MSR, ...) w/ BERT (",(0,i.kt)("a",{parentName:"td",href:"https://github.com/Kungbib/swedish-bert-models#bert-base-fine-tuned-for-swedish-ner"},"KungBib"),")"),(0,i.kt)("td",{parentName:"tr",align:null},"480MB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0.928"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SUC 3.0 (PER, LOC, ORG, TME, MSR, ...) w/ BERT Quantized"),(0,i.kt)("td",{parentName:"tr",align:null},"120MB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0.928"))))),(0,i.kt)("p",null,"I believe it's important to note that Quantized models are also much faster running ~ 4 times faster (avg 360ms went to 80ms on a CPU for flair).",(0,i.kt)("br",{parentName:"p"}),"\n","Quantization updates the f32 into int8 which allows the model to more efficiently utilize CPU and the ONNX-runtime also makes the whole model better at using CPU-instructions."),(0,i.kt)("h2",{id:"deploying-on-streamlitiosharing"},"Deploying on streamlit.io/sharing"),(0,i.kt)("p",null,"And for the final part! \ud83c\udf89\nFirst you need a new public repository on GitHub with the streamlit & model code. This requires to set up a ",(0,i.kt)("inlineCode",{parentName:"p"},"requirements.txt")," with all necessary dependencies."),(0,i.kt)("p",null,"Then you need to figure out how you'll host your model if it's too large. I found GitHub LFS to work out decently, but the cap was pretty small (1GB / Month) and I broke the limit on my 3rd model. I went ahead and registered on ",(0,i.kt)("a",{parentName:"p",href:"https://www.backblaze.com"},"Backblaze")," which has great reviews, but I think the best solution in my shoes would be to host it through HuggingFace Model storage (free if public!).\n",(0,i.kt)("strong",{parentName:"p"},"edit:")," I actually ended up storing the flair model on ",(0,i.kt)("a",{parentName:"p",href:"https://huggingface.co/londogard/flair-swe-ner"},"huggingface.co/londogard/flair-swe-ner")," \ud83e\udd17."),(0,i.kt)("p",null,"Setting up the script itself was quite easy for Flair."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# load tagger for POS and\n@st.cache(allow_output_mutation=True)\ndef load_model():\n    tagger = SequenceTagger.load(\'best-model-large-data.pt\')\n    return tagger\n\n@st.cache(allow_output_mutation=True, hash_funcs={SequenceTagger: lambda  _: None})\ndef predict(model, text):\n    manual_sentence = Sentence(manual_user_input)\n    model.predict(manual_sentence)\n    return render_ner_html(manual_sentence, wrap_page=False)\n\ntagger = load_model()\n\nst.title("Swedish Named Entity Recognition (NER) tagger")\nst.subheader("Created by [Londogard](https://londogard.com) (Hampus Lond\xf6g\xe5rd)")\nst.title("Please type something in the box below")\nmanual_user_input = st.text_area("")\n\nif len(manual_user_input) > 0:\n    sentence = predict(tagger, manual_user_input)\n    st.success("Below is your tagged string.")\n    st.write(sentence, unsafe_allow_html=True)\n')),(0,i.kt)("p",null,"It's important to note how I've placed the caching solution. I both cache the model loading & predictions to keep it as speedy as possible.   "),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"allow_output_mutation")," option skips hashing the output to validate that the cache is correct, we don't care if output has been modified really."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"hash_funcs={SequenceTagger: lambda  _: None}")," is ",(0,i.kt)("strong",{parentName:"p"},"incredibly important"),".",(0,i.kt)("br",{parentName:"p"}),"\n","The flair model are pretty slow to hash, especially if quantized. It's possible to use ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," which is a unique ID for the python object that lasts the full lifetime, but because I know that the model wont change I simply use ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda _: None")," to not do any lookup at all.",(0,i.kt)("br",{parentName:"p"}),"\n","If the model input would change in-between using ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," is the best approach. Note that neither of this approaches are any good if you wanna compare an object to another (e.g. two string inputs), there we should just keep standard hashing."),(0,i.kt)("h2",{id:"outro"},"Outro"),(0,i.kt)("p",null,"I trained Flair embeddings which is a much simpler approach than Transformers and achieved almost SotA while having a much smaller & simpler model (~2/3rd of the size). But in the end I was very impressed by how well quantization applies for CPU utilization so I also applied the same approach for BERT-ner by KB, where I even did a ONNX Quantization which has been shown to be even more effective than PyTorch own quantization, but then again it requires the ONNX runtime."),(0,i.kt)("p",null,"Both models are available on the same device / streamlit configuration, find them on ",(0,i.kt)("a",{parentName:"p",href:"https://londogard.com/ner"},"londogard.com/ner"),".",(0,i.kt)("br",{parentName:"p"}),"\n","The flair model is available through HuggingFace \ud83e\udd17 through the following: ",(0,i.kt)("a",{parentName:"p",href:"https://huggingface.co/londogard"},"londogard (huggingface.co)"),"."),(0,i.kt)("p",null,"Thanks for this time,\nHampus Lond\xf6g\xe5rd @ Londogard"))}h.isMDXComponent=!0}}]);